<?xml version="1.0"?>
<opml version="2.0">
  <head>
    <ownerEmail>zhangxiaoyang.hit@gmail.com</ownerEmail>
  </head>
  <body>
    <outline text="lintcode" >
      <outline text="String" >
        <outline text="two strings are anagrams" >
          <outline text="描述" _note="有两个字符串s和t，判断s和t是否为anagram。anagram是说s中的字符和t中字符一样多且字符字符所属的集合一样。比如：abcd、dcab，比如aabc、baca。&#10;" />
          <outline text="思路" _note="O(n)时间，O(1)空间。先用一个数组int chars[UCHAR_MAX+1]存每个字符出现的个数，默认是0。一次遍历，遍历s的长度（即t的长度），把chars[s[i]]++，chars[t[i]]--。最后，再来一次遍历，此次遍历的是chars，看是不是每个元素都是0。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param s: The first string&#10;     * @param b: The second string&#10;     * @return true or false&#10;     */&#10;    bool anagram(string s, string t) {&#10;        int chars[UCHAR_MAX + 1] = {0};&#10;        int sLen = s.size();&#10;        int tLen = t.size();&#10;        &#10;        if (sLen != tLen)&#10;            return false;&#10;            &#10;        for (int i = 0; i &amp;lt; sLen; i++) {&#10;            chars[(unsigned char)s[i]]++;&#10;            chars[(unsigned char)t[i]]--;&#10;        }&#10;        for (int i = 0; i &amp;lt; UCHAR_MAX + 1; i++) {&#10;            if (chars[i])&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;};&#10;" /></outline>
        <outline text="compare strings" >
          <outline text="描述" _note="有2个字符串A和B（由大写字母组成），判断B中的字符是不是都在A中。比如，abcd、ac，这个都在。注意，需要考虑数目，比如abcd、aac，就不在了，因为B有2个a，而A有1个a。&#10;" />
          <outline text="思路" _note="因为A和B由大写字母组成，可以设置一个int chars[26] = {0}，和anagram类似。然后，遍历A和B，出现在A的字符则++，出现在B的字符则--。最后，遍历chars，看有没有元素小于0，如果有说明B中有字符不存在A中，否则说明B中的字符都在A中。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: A string includes Upper Case letters&#10;     * @param B: A string includes Upper Case letter&#10;     * @return:  if string A contains all of the characters in B return true &#10;     *           else return false&#10;     */&#10;    bool compareStrings(string A, string B) {&#10;        int chars[26] = {0};&#10;        &#10;        int ALen = A.size();&#10;        int BLen = B.size();&#10;        int len = ALen &amp;gt; BLen ? ALen : BLen;&#10;        &#10;        for (int i = 0; i &amp;lt; len; i++) {&#10;            i &amp;lt; ALen &amp;amp;&amp;amp; chars[A[i] - 'A']++;&#10;            i &amp;lt; BLen &amp;amp;&amp;amp; chars[B[i] - 'A']--;&#10;        }&#10;        for (int i = 0; i &amp;lt; 26; i++) {&#10;            if(chars[i] &amp;lt; 0)&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;};&#10;" /></outline>
        <outline text="strstr" >
          <outline text="描述" _note="有2个字符串source和target，返回target在source中出现的下标位置。如皋不存在，则返回-1。" />
          <outline text="思路" _note="KMP可以很好的解决这个问题，这里用最暴力的O(n2)算法解决。需要注意的是，source和target可能是NULL，这个不代表字符串是“”。所以，有NULL就返回-1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * Returns a index to the first occurrence of target in source,&#10;     * or -1  if target is not part of source.&#10;     * @param source string to be scanned.&#10;     * @param target string containing the sequence of characters to match.&#10;     */&#10;    int strStr(const char *source, const char *target) {&#10;        if (source == NULL || target == NULL)&#10;            return -1;&#10;            &#10;        int sLen = strlen(source);&#10;        int tLen = strlen(target);&#10;        if (tLen &amp;gt; sLen)&#10;            return -1;&#10;            &#10;        for (int i = 0; i &amp;lt; sLen - tLen + 1; i++) {&#10;            if (strncmp(&amp;amp;source[i], &amp;amp;target[0], tLen) == 0)&#10;                return i;&#10;        }&#10;        return -1;&#10;    }&#10;};" /></outline>
        <outline text="anagrams" >
          <outline text="描述" _note="有一个vector，里面存放的是若干个字符串，现在需要把里面的anagrams字符串找出来。比如，[&quot;ab&quot;, &quot;ba&quot;, &quot;cd&quot;, &quot;dc&quot;, &quot;e]，最后需要得到[&quot;ab&quot;, &quot;ba&quot;, &quot;cd&quot;, &quot;dc&quot;]，顺序无所谓。需要注意的是，所谓的anagrams字符串，一定是有2个或2个以上的，要不然你和谁anagrams啊，是吧？" />
          <outline text="思路" _note="需要用一个map，来存储每个字符串出现的位置，字符串是排序好的，这一来了下一个字符串也sort一下，就可以看看map中有没有了。之所以记录位置，是因为map的key已经是排序的了，原来的字符串只能通过位置去输入的vector中取。总的时间是O(n2logn)，如果不用排序，就可以降到O(n2)了。能想到的方法是对每一个字符串做一个hash，map存储的是hash-&amp;gt;位置。问题是，如何计算hash呢，使得hash(abc) = hash(bca)？" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param strs: A list of strings&#10;     * @return: A list of strings&#10;     */&#10;    vector&amp;lt;string&amp;gt; anagrams(vector&amp;lt;string&amp;gt; &amp;amp;strs) {&#10;        int strsLen = strs.size();&#10;        vector&amp;lt;string&amp;gt; result;&#10;        map&amp;lt;string, int&amp;gt; cache;&#10;        &#10;        for (int i = 0; i &amp;lt; strsLen; i++) {&#10;            string s = strs[i];&#10;            sort(s.begin(), s.end());&#10;            if (cache.find(s) == cache.end()) {&#10;                cache[s] = i;&#10;            }&#10;            else {&#10;                if (cache[s] &amp;gt;= 0) {&#10;                    result.push_back(strs[cache[s]]);&#10;                    cache[s] = -1;&#10;                }&#10;                result.push_back(strs[i]);   &#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="longest common substring" >
          <outline text="描述" _note="求2个字符串A和B的最长公共子串，注意不是子序列。" />
          <outline text="思路" _note="使用动态规划解决 s[i, j]表示以i下标结尾的A子串a和以j下标结尾的B子串b，a和b的最长公共子串。所以，只有A[i] == B[i]，a和b才会有最长公共子串，否则为0。s[i, j] = s[i-1, j-1] + 1 if A[i] == B[j] else 0。为了方便计算，使用的数组为dp[ALen+1][BLen+1]，新添加的第0行和第0列，可以直接得出dp[0][.] = 0，dp[.][0] = 0。" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param A, B: Two string.&#10;     * @return: the length of the longest common substring.&#10;     */&#10;    int longestCommonSubstring(string &amp;amp;A, string &amp;amp;B) {&#10;        int ALen = A.size();&#10;        int BLen = B.size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(ALen + 1, vector&amp;lt;int&amp;gt;(BLen + 1, 0));&#10;        &#10;        int result = 0;&#10;        for (int i = 0; i &amp;lt; ALen + 1; i++) {&#10;            for (int j = 0; j &amp;lt; BLen + 1; j++) {&#10;                if (!i || !j)&#10;                    dp[i][j] = 0;&#10;                else if (A[i - 1] == B[j - 1]) {&#10;                    dp[i][j] = dp[i - 1][j - 1] + 1;&#10;                    result = max(result, dp[i][j]);&#10;                }&#10;                else&#10;                    dp[i][j] = 0;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="longest common prefix" >
          <outline text="描述" _note="有一个vector，里面存储了若干个string，计算这些string的最长前缀。" />
          <outline text="思路" _note="两层循环，第一层变化前缀的下标，第二层遍历所有字符串在该下标下是否是相等的。" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param strs: A list of strings&#10;     * @return: The longest common prefix&#10;     */&#10;    string longestCommonPrefix(vector&amp;lt;string&amp;gt; &amp;amp;strs) {&#10;        int strsLen = strs.size();&#10;        if (!strsLen)&#10;            return &quot;&quot;;&#10;            &#10;        string result;&#10;        for (int i = 0; i &amp;lt; strs[0].size(); i++) {&#10;            for (int j = 0; j &amp;lt; strsLen; j++) {&#10;                if (strs[j][i] != strs[0][i])&#10;                    return result;&#10;            }&#10;            result += strs[0][i];&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="atoi" >
          <outline text="描述" _note="把一个字符串转换成int类型，如“-123abc“转成-123。" />
          <outline text="思路" _note="把输入字符串看成通用形式abc123abc456，即数字的左右两侧会有非数字。依次从左到右读入字符，如果没有还没有遇到数字，就继续读入下一个字符，一旦读入数字，则继续读入数字直到遇到非数字停止。所以，abc123abc456会转换成123。还需要注意正负号，如果还没有读入数字，读入正负号则记录到flag，如果已经读入了数字，新遇到正负号则停止（此时新遇到的正负号就是非数字了，所以按照前面的规则，停止）。通过result = result*10 + str[i] - '0'来不断更新result值，最后result*flag就是转换后的值了。在不断更新result的时候，每次都要检验是否超出int的表示范围，如果超出则返回边界值。之所以要每次都要检测，是因为用long存储的结果值，如果输入的数字太大，long也溢出了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param str: A string&#10;     * @return An integer&#10;     */&#10;    int intOverflow(long num) {&#10;        if (num &amp;gt; INT_MAX)&#10;            return INT_MAX;&#10;        if (num &amp;lt; INT_MIN)&#10;            return INT_MIN;&#10;        return 0;&#10;    }&#10;    int atoi(string str) {&#10;        long result = 0;&#10;        int strLen = str.size();&#10;        int flag = 0;&#10;        &#10;        for (int i = 0; i &amp;lt; strLen; i++) {&#10;            if (!flag &amp;amp;&amp;amp; (str[i] == '+' || str[i] == '-')) {&#10;                if (str[i] == '+')&#10;                    flag = 1;&#10;                else&#10;                    flag = -1;&#10;            }&#10;            else if (str[i] &amp;gt;= '0' &amp;amp;&amp;amp; str[i] &amp;lt;= '9') {&#10;                if (!flag)&#10;                    flag = 1;&#10;                int num = intOverflow(result * flag);&#10;                if (num)&#10;                    return num;&#10;                result = result * 10 + str[i] - '0';&#10;            }&#10;            else if (!flag)&#10;                continue;&#10;            else&#10;                break;&#10;        }&#10;        result *= flag;&#10;        &#10;        int num = intOverflow(result);&#10;        if (num)&#10;            return num;&#10;        return (int)result;&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Integer Array" >
        <outline text="remove element" >
          <outline text="描述" _note="原地去除数组的给定元素，返回新的数组长度。比如数组为{1,2,2,3}，给定元素为2，则把前2个元素赋值为{1,3}，返回新的长度为2。" />
          <outline text="思路" _note="使用一个index变量，初始值为0，表示数组的0下标及后面的数都是无效的，同时也表示数组的新长度为0。然后，用i遍历数组，如果A[i] != 给定元素，则A[index++] = A[i]，意思是说，我找到了一个非指定元素，我需要保留他，把他放在index的位置，并且index++，此时的新数组长度为1，下标0处已经放了一个元素了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /** &#10;     *@param A: A list of integers&#10;     *@param elem: An integer&#10;     *@return: The new length after remove&#10;     */&#10;    int removeElement(vector&amp;lt;int&amp;gt; &amp;amp;A, int elem) {&#10;        int index = 0;&#10;        int ALen = A.size();&#10;        &#10;        for (int i = 0; i &amp;lt; ALen; i++) {&#10;            if (A[i] != elem)&#10;                A[index++] = A[i];&#10;        }&#10;        &#10;        return index;&#10;    }&#10;};&#10;" /></outline>
        <outline text="subarray sum" >
          <outline text="描述" _note="有一个int数组，找出一个子数组，使得子数组的和是0，子数组的元素连续。比如，{1,2,-1,-1,2}，返回{1,3}，即下标1到3的子数组和为0。" />
          <outline text="思路" _note="可以使用一个map作为缓存，这样时间复杂度为O(n)。具体方法是，sum=0，遍历数组，不断更新sum+=A[i]。在一次更新sum后，判断map中有没有key=sum的元素，如果没有，则把在map中新加入一个map[sum] = i，表示从0到i的和为key，i为value。如果map中已经有key=sum的元素了，而当前的和也是sum，说明map[sum] + 1到i的子数组和为0，正是因为和是0才导致出现了2次相同的sum。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: A list of integers includes the index of the first number &#10;     *          and the index of the last number&#10;     */&#10;    vector&amp;lt;int&amp;gt; subarraySum(vector&amp;lt;int&amp;gt; nums){&#10;        int numsLen = nums.size();&#10;        map&amp;lt;int, int&amp;gt; cache;&#10;        int sum = 0;&#10;        vector&amp;lt;int&amp;gt; result;&#10;        &#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            sum += nums[i];&#10;            if (sum == 0) {&#10;                result.push_back(0);&#10;                result.push_back(i);&#10;                break;&#10;            }&#10;            else if (cache.find(sum) == cache.end())&#10;                cache[sum] = i;&#10;            else {&#10;                result.push_back(cache[sum] + 1);&#10;                result.push_back(i);&#10;                break;&#10;            }&#10;        }&#10;        &#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="remove duplicates from sorted array" >
          <outline text="描述" _note="有一个排好序的数组，删除其中重复的元素，使得重复的元素只保留一个，原地进行删除，返回新的数组长度。比如，A={1,2,2,3}，需要把A变成{1,2,3}，返回长度3。" />
          <outline text="思路" _note="设置一个index下标，最开始指向0，然后使用i遍历数组，从1开始遍历。如果和index的元素相等，则继续i++，否则就A[++index] = A[i]这样index就指向了新的元素。最终，返回index + 1就是新数组的长度。在这里，index可以理解为“我指向新数组的最后一个元素，随着i的遍历，不断扩张”。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: a list of integers&#10;     * @return : return an integer&#10;     */&#10;    int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        int numsLen = nums.size();&#10;        if (numsLen &amp;lt;= 1)&#10;            return numsLen;&#10;            &#10;        int index = 0;&#10;        for (int i = 1; i &amp;lt; numsLen; i++) {&#10;            if (nums[i] != nums[index])&#10;                nums[++index] = nums[i];&#10;        }&#10;        return index + 1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="merge sorted array" >
          <outline text="描述" _note="有2个排序好的数组，A[m]和B[n]，将其合并到A[m+n]中，使得A[m+n]也是排序好的。" />
          <outline text="思路" _note="使用一个index = m + n -1，表示新数组的最后一个元素，然后i = m - 1；j = n - 1分别表示A[m]和B[n]的最后一个元素，依次比较A[i]和B[j]，选择大的把值写入到A[index]，然后index--，直到index &amp;lt; 0停止循环。要注意的是，m和n可能一个长一个短，就会出现一个数组先遍历完的情况，可以根据i或j &amp;lt; 0判断，然后把另一个数组的值依次往A[index]写就可以了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: sorted integer array A which has m elements, &#10;     *           but size of A is m+n&#10;     * @param B: sorted integer array B which has n elements&#10;     * @return: void&#10;     */&#10;    void mergeSortedArray(int A[], int m, int B[], int n) {&#10;        int index = m + n - 1;&#10;        int i = m - 1;&#10;        int j = n - 1;&#10;        while (index &amp;gt;= 0) {&#10;            if (i &amp;lt; 0) {&#10;                A[index--] = B[j--];&#10;                continue;&#10;            }&#10;            if (j &amp;lt; 0) {&#10;                A[index--] = A[i--];&#10;                continue;                &#10;            }&#10;            if (A[i] &amp;gt;= B[j])&#10;                A[index--] = A[i--];&#10;            else&#10;                A[index--] = B[j--];&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="product of array exclude itself" >
          <outline text="描述" _note="给定一个数组，如A={1,2,3}，返回B={6,3,2}，计算规则是：非当前下标的其它元素之积，对于A[0]，对应的B[0]=A[1]*A[2]=6。不能在计算中使用除法（如果可以使用，先全部求一下积，然后计算每个元素的时候，除以当前对应的A中元素即可）" />
          <outline text="思路" _note="使用2个数组，分别为left[N]和right[N]，left[i]表示第i个元素左边其它元素之积，right[i]同理。先通过一次遍历，填充left、right。最后再一次遍历，使用B[i]=left[i]*right[i]。需要注意的是，left和right的计算规律及left和right初始的每一个元素要置为1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: Given an integers array A&#10;     * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]&#10;     */&#10;    vector&amp;lt;long long&amp;gt; productExcludeItself(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        int numsLen = nums.size();&#10;        vector&amp;lt;long long&amp;gt; left(numsLen, 1);&#10;        vector&amp;lt;long long&amp;gt; right(numsLen, 1);&#10;        vector&amp;lt;long long&amp;gt; result(numsLen, 1);&#10;        for (int i = 1; i &amp;lt; numsLen; i++) {&#10;            left[i] = left[i - 1] * nums[i - 1];&#10;            right[numsLen - i - 1] = right[numsLen -i] * nums[numsLen - i];&#10;        }&#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            result[i] = left[i] * right[i];&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="first missing positive" >
          <outline text="描述" _note="找到数组中第一个缺失的正数，比如{3,2,3}缺失了1，{1,2,3}缺失了4。" />
          <outline text="思路" _note="最直观的想法是排序，然后找。但是，题目要求使用O(n)时间，常数空间。思路是，我们把数放到他们应该在的地方，比如1放到0的位置，5放到4的位置，这样放好以后，就可以遍历一次找到不对的那个数，这样就找到了缺失的正数了。还要注意的是，我们只交换符合要求的数，不符合要求的数跳过，如果他们运气好，后面可能会被其他的数交换，如果运气不好，就呆在那个位置了。所谓的符合要求是指1~N之间的数，N是数组的长度，并且还要判断，如果在某个位置已经放对了一个数了，后面又遇到了一次这个数，此时的做法是不交换。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**    &#10;     * @param A: a vector of integers&#10;     * @return: an integer&#10;     */&#10;    int firstMissingPositive(vector&amp;lt;int&amp;gt; A) {&#10;        int ALen = A.size();&#10;        int i = 0;&#10;        while (i &amp;lt; ALen) {&#10;            if (A[i] != (i + 1) &amp;amp;&amp;amp; A[i] &amp;gt;= 1 &amp;amp;&amp;amp; A[i] &amp;lt;= ALen &amp;amp;&amp;amp; A[i] != A[A[i] - 1])&#10;                swap(A[i], A[A[i] - 1]);&#10;            else&#10;                i++;&#10;        }&#10;        &#10;        int result = ALen + 1;&#10;        for (int i = 0; i &amp;lt; ALen; i++) {&#10;            if (A[i] != (i + 1)) {&#10;                result = i + 1;&#10;                break;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="3 sum closest" >
          <outline text="描述" _note="给定一个数组，从里面找3个数，使得他们的和和给定的target最接近。" />
          <outline text="思路" _note="暴力方法是O(n3)，题目要求O(n2)完成。可以先对数组排序，O(nlogn)。然后外层使用一个循环i，内层使用2个指针j和k，分别指向i + 1和N-1，然后不断移动j和k，即j++、k--（夹逼）。" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param numbers: Give an array numbers of n integer&#10;     * @param target: An integer&#10;     * @return: return the sum of the three integers, the sum closest target.&#10;     */&#10;    int threeSumClosest(vector&amp;lt;int&amp;gt; nums, int target) {&#10;        sort(nums.begin(), nums.end());&#10;        int numsLen = nums.size();&#10;        int result = 0;&#10;        int minDiff = INT_MAX;&#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            int j = i + 1;&#10;            int k = numsLen - 1;&#10;            while (j &amp;lt; k) {&#10;                int sum = nums[i] + nums[j] + nums[k];&#10;                int diff = abs(sum - target);&#10;                if (diff &amp;lt; minDiff) {&#10;                    minDiff = diff;&#10;                    result = sum;&#10;                }&#10;                if (diff == 0)&#10;                    return sum;&#10;                if (sum &amp;lt;= target)&#10;                    j++;&#10;                else&#10;                    k--;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="3 sum" >
          <outline text="描述" _note="给定一个数组，从中找3个元素使得和为0，把符合这个要求的三元组都找出来（不可重复）。" />
          <outline text="思路" _note="还是先排序O(nlogn)，然后使用一个i变量进行一层变量。内层使用j和k，j=i+1、k=N-1，夹逼。如果遇到了和为0的情况，就把结果存起来。到这里应该没啥问题了。关键问题是，如果有重复的三元组怎么办。方法是，对&#10;i、j、k，每次进行一轮循环时，都判断下i-1、j-1、k+1存的值和当前的值是不是一样，一样的话就不进行深入的判断了，直接i++、j++、k--。" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param numbers : Give an array numbers of n integer&#10;     * @return : Find all unique triplets in the array which gives the sum of zero.&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; threeSum(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        int numsLen = nums.size();&#10;        sort(nums.begin(), nums.end());&#10;        &#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1])&#10;                continue;&#10;                &#10;            int j = i + 1;&#10;            int k = numsLen - 1;&#10;            while (j &amp;lt; k) {&#10;                if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) {&#10;                    j++;&#10;                    continue;&#10;                }&#10;                if (k &amp;lt; numsLen - 1 &amp;amp;&amp;amp; nums[k] == nums[k + 1]) {&#10;                    k--;&#10;                    continue;&#10;                }&#10;                    &#10;                int sum = nums[i] + nums[j] + nums[k];&#10;                if (sum == 0) {&#10;                    vector&amp;lt;int&amp;gt; tmp;&#10;                    tmp.push_back(nums[i]);&#10;                    tmp.push_back(nums[j]);&#10;                    tmp.push_back(nums[k]);&#10;                    result.push_back(tmp);&#10;                }&#10;                &#10;                if (sum &amp;lt;= 0)&#10;                    j++;&#10;                else&#10;                    k--;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="2 sum" >
          <outline text="描述" _note="有一个数组，从中找到2个数，使得他们的和等于给定的一个数。最后返回这2个数的数组下标。" />
          <outline text="思路" _note="首先想到的是把数组排序，但是下标就乱了，而且这个题目希望我们使用O(n)时间解决。方法是，使用一个map，存储元素的值和对应的下标。一次遍历数组，一边遍历，一边更新map，并且从map中查找有没有一个数和当前的A[i]之和是target。因为是2 sum嘛，总会在第2个数的时候可以从map中找到第1个数。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /*&#10;     * @param numbers : An array of Integer&#10;     * @param target : target = numbers[index1] + numbers[index2]&#10;     * @return : [index1+1, index2+1] (index1 &amp;lt; index2)&#10;     */&#10;    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) {&#10;        map&amp;lt;int, int&amp;gt; cache;&#10;        int numsLen = nums.size();&#10;        vector&amp;lt;int&amp;gt; result;&#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            int num = target - nums[i];&#10;            if (cache.find(num) != cache.end()) {&#10;                result.push_back(cache[num] + 1);&#10;                result.push_back(i + 1);&#10;                return result;&#10;            }&#10;            cache[nums[i]] = i;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="partition array" >
          <outline text="描述" _note="有一个数组，给定一个数，把小于该数的数组中的数放到左边，大于该数的放到右边。最后返回“左边”最后一个元素的下一个元素的下标。" />
          <outline text="思路" _note="使用2根指针，left=0，right=N-1。然后一个循环，里面不断对数字进行交换即可。需要注意的是，必须使用left&amp;lt;=right作为判断情况，比如{10,10,X,1,1}，给定5。如果使用left&amp;lt;right的话，到X的位置的时候就停止了，但是X有可能比5大，也有可能比5小。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    void swap(vector&amp;lt;int&amp;gt;&amp;amp; nums, int m, int n) {&#10;        int tmp = nums[m];&#10;        nums[m] = nums[n];&#10;        nums[n] = tmp;&#10;    }&#10;    int partitionArray(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {&#10;        int numsLen = nums.size();&#10;        int left = 0;&#10;        int right = numsLen - 1;&#10;        while (left &amp;lt;= right) {&#10;            while (left &amp;lt;= right &amp;amp;&amp;amp; nums[left] &amp;lt; k)&#10;                left++;&#10;            while (left &amp;lt;= right &amp;amp;&amp;amp; nums[right] &amp;gt;= k)&#10;                right--;&#10;            if (left &amp;lt;= right) {&#10;                swap(nums, left, right);&#10;                left++;&#10;                right--;&#10;            }&#10;        }&#10;        return left;&#10;    }&#10;};&#10;" /></outline>
        <outline text="remove duplicates from sorted array ii" >
          <outline text="描述" _note="从一个排序的数组中删除重复的元素，重复3次或以上才删除。最后返回新数组的元素个数。" />
          <outline text="思路" _note="使用index指针，指向下标2，表示下一个要存储的数组放到index的位置。然后使用i进行遍历，初始值为2。如果A[index-2] != A[i]，则把A[i]赋值到index下标。最后返回的时候，index的值就是新数组元素的个数。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: a list of integers&#10;     * @return : return an integer&#10;     */&#10;    int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        int numsLen = nums.size();&#10;        if (numsLen &amp;lt;= 2)&#10;            return numsLen;&#10;            &#10;        int index = 2;&#10;        for (int i = index; i &amp;lt; numsLen; i++) {&#10;            if (nums[i] != nums[index - 2])&#10;                nums[index++] = nums[i];&#10;        }&#10;        return index;&#10;    }&#10;};&#10;" /></outline>
        <outline text="merge sorted array ii" >
          <outline text="描述" _note="有两个排序好的数组，将他们合并成一个有序的数组。" />
          <outline text="思路" _note="开一个新的数组，大小为两个数组长度和。然后分别设置i和j指向两个数组，一边遍历一边往新数组填数。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A and B: sorted integer array A and B.&#10;     * @return: A new sorted integer array&#10;     */&#10;    vector&amp;lt;int&amp;gt; mergeSortedArray(vector&amp;lt;int&amp;gt; &amp;amp;A, vector&amp;lt;int&amp;gt; &amp;amp;B) {&#10;        int ALen = A.size();&#10;        int BLen = B.size();&#10;        &#10;        vector&amp;lt;int&amp;gt; result(ALen + BLen, 0);&#10;        int i = 0;&#10;        int j = 0;&#10;        int index = 0;&#10;        while (i &amp;lt; ALen || j &amp;lt; BLen) {&#10;            if (i &amp;gt;= ALen) {&#10;                result[index++] = B[j++];&#10;                continue;&#10;            }&#10;            if (j &amp;gt;= BLen) {&#10;                result[index++] = A[i++];&#10;                continue;&#10;            }&#10;            if (A[i] &amp;lt; B[j])&#10;                result[index++] = A[i++];&#10;            else&#10;                result[index++] = B[j++];&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="subarray sum closest" >
          <outline text="描述" _note="有一个数组，找出一个子数组（元素连续），使得其元素的和最接近0。如果有多个结果，给出一个即可。" />
          <outline text="思路" _note="最暴力的方法是O(n2)，但这里要求是O(nlogn)。先说技巧，这里把所有的数组前缀之和都存下来prefixes[N]。这样的话，如果abs(prefixes[x] - prefixes[y])接近0，那么x,y所对应的下标m,n就是答案了！所以，一开始我使用了map，key是prefix（某前缀的和），value是前缀最后一个元素的index。但是这样有很大的问题，因为有可能有多个前缀的和是一样的，这样的话在map里就只存了一个。其实，如果有多个前缀的和一样，说明一定有一个子数组的和是0的！最后，使用的还是prefixes数组，只不过数组的元素是一个pair，里面有2个值，分别是前缀和、index。这样，按照前缀和排序，我们依次比较相邻的2个prefixes[i].first、prefixes[i-1].first，找到abs(prefixes[i].first-prefixes[i-1].first)最小的，就可以了，最后返回对应的prefixes[i].second和prefixes[i-1].second。这个题目花了很长时间，总结来说，看logn要想到排序、查找。还有前缀的方式，如果题目是让求元素和为0的子数组，就可以只花O(n)的时间了，用一个map记录prefixes[i]和index，如果map里已经有prefixes[i]的值了，说明之前记录的值对应的index+1到i这个子数组的和是0，因为前缀相等了！" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: A list of integers includes the index of the first number &#10;     *          and the index of the last number&#10;     */&#10;    vector&amp;lt;int&amp;gt; subarraySumClosest(vector&amp;lt;int&amp;gt; nums){&#10;        int numsLen = nums.size();&#10;        vector&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; prefixes(numsLen, make_pair(0, 0));&#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            prefixes[i].first = i == 0&#10;                ? nums[i]&#10;                : prefixes[i - 1].first + nums[i];&#10;            prefixes[i].second = i;&#10;        }&#10;        sort(prefixes.begin(), prefixes.end());&#10;        &#10;        vector&amp;lt;int&amp;gt; result(2, prefixes[0].second);&#10;        int minDiff = abs(prefixes[0].first);&#10;        for (int i = 1; i &amp;lt; numsLen; i++) {&#10;            int diff = abs(prefixes[i].first - prefixes[i - 1].first);&#10;            if (diff &amp;lt; minDiff) {&#10;                minDiff = diff;&#10;                result[0] = min(prefixes[i].second, prefixes[i - 1].second) + 1;&#10;                result[1] = max(prefixes[i].second, prefixes[i - 1].second);&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="4 sum" >
          <outline text="描述" _note="有一个数组，从中选4个数字，使得他们的和等于给定的数。" />
          <outline text="思路" _note="这个和3sum的方法一模一样，先把数组排序，开2层循环，内层使用2个指针，分别从左右两侧夹逼。需要注意的是，为了去重，在最内层的循环中，需要看nums[m] == nums[m-1]是否成立，如果成立，则continue，同时m++。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param numbers: Give an array numbersbers of n integer&#10;     * @param target: you need to find four elements that's sum of target&#10;     * @return: Find all unique quadruplets in the array which gives the sum of &#10;     *          zero.&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; fourSum(vector&amp;lt;int&amp;gt; nums, int target) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        int numsLen = nums.size();&#10;        sort(nums.begin(), nums.end());&#10;        for (int i = 0; i &amp;lt; numsLen; i++) {&#10;            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1])&#10;                continue;&#10;            for (int j = i + 1; j &amp;lt; numsLen; j++) {&#10;                if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1])&#10;                    continue;&#10;                int m = j + 1;&#10;                int n = numsLen - 1;&#10;                while (m &amp;lt; n) {&#10;                    if (m &amp;gt; j + 1 &amp;amp;&amp;amp; nums[m] == nums[m - 1]) {&#10;                        m++;&#10;                        continue;&#10;                    }&#10;                    int sum = nums[i] + nums[j] + nums[m] + nums[n];&#10;                    if (sum == target) {&#10;                        vector&amp;lt;int&amp;gt; tmp;&#10;                        tmp.push_back(nums[i]);&#10;                        tmp.push_back(nums[j]);&#10;                        tmp.push_back(nums[m]);&#10;                        tmp.push_back(nums[n]);&#10;                        result.push_back(tmp);&#10;                        m++;&#10;                        n--;&#10;                    }&#10;                    else if (sum &amp;lt; target)&#10;                        m++;&#10;                    else&#10;                        n--;&#10;                }&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Binary Search" >
        <outline text="sqrtx" >
          <outline text="描述" _note="对一个数字开平方。" />
          <outline text="思路" _note="使用二分查找，查找范围是0-N，终止循环的条件是pow(mid, 2) == N || (pow(mid, 2) &amp;lt; N &amp;amp;&amp;amp; pow(mid+1, 2) &amp;gt; N)。需要注意的是，如果用一个变量临时存pow(mid, 2)，应该使用long，防止溢出。还有就是，最后的return应该是永远不会执行的，所以返回-1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param x: An integer&#10;     * @return: The sqrt of x&#10;     */&#10;    int sqrt(int x) {&#10;        int left = 0;&#10;        int right = x;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            long power = pow(mid, 2);&#10;            if (power == x || (power &amp;lt; x &amp;amp;&amp;amp; pow(mid + 1, 2) &amp;gt; x))&#10;                return mid;&#10;            if (power &amp;lt; x)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="search insert position" >
          <outline text="描述" _note="有一个有序数组，从数组中找到给定数值的下标。如果数组中没有给定的数值，那么就返回这个数值应该存储的下标。" />
          <outline text="思路" _note="二分查找，如果没有找到，则最后返回left即可，因为left就表示应该存储的下标位置。" />
          <outline text="代码" _note="class Solution {&#10;    /** &#10;     * param A : an integer sorted array&#10;     * param target :  an integer to be inserted&#10;     * return : an integer&#10;     */&#10;public:&#10;    int searchInsert(vector&amp;lt;int&amp;gt; &amp;amp;A, int target) {&#10;        int ALen = A.size();&#10;        int left = 0;&#10;        int right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (A[mid] == target)&#10;                return mid;&#10;            if (A[mid] &amp;lt; target)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return left;&#10;    }&#10;};&#10;" /></outline>
        <outline text="search a 2d matrix" >
          <outline text="描述" _note="有一个矩阵，矩阵每一行的数字都是排序好的，矩阵第一列的l数字也是排序好的。给定一个数字，判断这个数字是否在矩阵中。" />
          <outline text="思路" _note="普通的暴力搜索方法，是O(n2)。这里要充分利用有序这个特点。可以先使用二分查找找到元素所在的行，然后再在这一行内二分查找给定的元素，时间复杂度O(logn)。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param matrix, a list of lists of integers&#10;     * @param target, an integer&#10;     * @return a boolean, indicate whether matrix contains target&#10;     */&#10;    bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix, int target) {&#10;        int row = searchRow(matrix, target);&#10;        if (row &amp;gt;= 0) {&#10;            int column = searchColumn(matrix[row], target);&#10;            if (column &amp;gt;= 0)&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;    int searchRow(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; matrix, int target) {&#10;        int left = 0;&#10;        int right = matrix.size() - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (matrix[mid][0] == target)&#10;                return mid;&#10;            if (matrix[mid][0] &amp;lt; target)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return left - 1;&#10;    }&#10;    int searchColumn(vector&amp;lt;int&amp;gt;&amp;amp; cells, int target) {&#10;        int left = 0;&#10;        int right = cells.size() - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (cells[mid] == target)&#10;                return mid;&#10;            if (cells[mid] &amp;lt; target)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary search" >
          <outline text="描述" _note="查找给定的数是否在一个有序数组中，返回第一次出现这个数的下标，注意：数组的元素可能会重复。" />
          <outline text="思路" _note="可以使用二分查找，关键是如何处理重复的元素。关键点在：if(A[mid] &amp;gt;= target) right = mid - 1;因为最后算出来的left会是期待存放target的位置，我们只需要再判断A[left]是否等于target，如果等于，left就是第一次出现target的位置了。否则返回-1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: The integer array.&#10;     * @param target: Target number to find.&#10;     * @return: The first position of target. Position starts from 0. &#10;     */&#10;    int binarySearch(vector&amp;lt;int&amp;gt; &amp;amp;array, int target) {&#10;        int left = 0;&#10;        int right = array.size() - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (array[mid] &amp;gt;= target)&#10;                right = mid - 1;&#10;            else&#10;                left = mid + 1;&#10;        }&#10;        return array[left] == target ? left : -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="wood cut" >
          <outline text="描述" _note="有若干个木块，需要对这些木块进行切割。最终得到若干个长度相同的木块。要求：最终得到的长度相同的木块的长度最长，并且木块个数要大于等于指定的k。" />
          <outline text="思路" _note="很难直接想到二分查找。题目最终使用二分查找，遍历的区域是1~max(L[N])，为啥不从0开始呢？因为，是要从遍历的区域中二分查找，选出来的数作为“相同木块的长度”，所以从0开始就可能得到length=0，进而在用L[i]/length时出错。通过设置一个全局变量result，记录当前符合要求(&amp;gt;=k)的最大长度。还有一个需要注意的地方，应该使用long存储，尽管传参是int，因为在(left + right)/2可能会溢出，比如left=INT_MAX，right=INT_MAX。long x = (left+right)/2；依然会得到错误的结果，因为在给long赋值时，left+right已经溢出了。所以要用long存储，而不是int。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /** &#10;     *@param L: Given n pieces of wood with length L[i]&#10;     *@param k: An integer&#10;     *return: The maximum length of the small pieces.&#10;     */&#10;    int max(vector&amp;lt;int&amp;gt; v) {&#10;        int _max = 0;&#10;        for (int i = 0; i &amp;lt; v.size(); i++)&#10;            if (v[i] &amp;gt; _max)&#10;                _max = v[i];&#10;        return _max;&#10;    }&#10;    int woodCut(vector&amp;lt;int&amp;gt; L, int k) {&#10;        long left = 1;&#10;        long right = max(L);&#10;        long result = 0;&#10;        while (left &amp;lt;= right) {&#10;            long length = (left + right) / 2;&#10;            int _k = 0;&#10;            for (int i = 0; i &amp;lt; L.size(); i++) {&#10;                _k += L[i] / length;   &#10;            }&#10;            if (_k &amp;gt;= k &amp;amp;&amp;amp; length &amp;gt; result)&#10;                result = length;&#10;                &#10;            if (_k &amp;lt; k)&#10;                right = length - 1;&#10;            else&#10;                left = length + 1;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="find minimum in rotated sorted array" >
          <outline text="描述" _note="给定一个经过翻转的有序数组，找出最小的元素，数组元素不重复。" />
          <outline text="思路" _note="翻转的一种情况是没翻转，如{1,2,3,4}。还一种情况是真的翻转了，如{3,4,1,2}。可以比较A[0]和A[N-1]来判断是否翻转了，对于第一种情况，可以直接返回A[0]。对于第二种情况，使用二分查找，查找的时候判断A[mid]是在左半部分，还是右半部分。如果在左边，那么就left = mid+1离开左边；如果在右边，那么就right = mid - 1继续像元素值小的地方前进。最后，left的位置就是最小值的位置。要始终铭记，left就是要查找的数的位置，如果没有这个数，就是应该放置这个数的位置。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param num: a rotated sorted array&#10;     * @return: the minimum number in the array&#10;     */&#10;    int findMin(vector&amp;lt;int&amp;gt; &amp;amp;num) {&#10;        int numLen = num.size();&#10;        if (num[0] &amp;lt;= num[numLen - 1])&#10;            return num[0];&#10;            &#10;        int left = 0;&#10;        int right = numLen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (num[mid] &amp;gt;= num[0])&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return num[left];&#10;    }&#10;};&#10;" /></outline>
        <outline text="find peak element" >
          <outline text="描述" _note="找到数组的peak下标（元素比左边和右边的值都大），比如{1, 2, 1, 3, 4, 5, 7, 6}，peak是2和7，下标分别是1和6。数组还有一个限制：相邻的数不同；A[0] &amp;lt; A[1] &amp;amp;&amp;amp; A[A.length - 2] &amp;gt; A[A.length - 1]." />
          <outline text="思路" _note="使用二分查找，找到比左右都大的值则返回，否则继续二分。需要注意的是，题目简化了很多，因为A[0] &amp;lt; A[1] &amp;amp;&amp;amp; A[A.length - 2] &amp;gt; A[A.length - 1]，表示不会出现这种情况{3,2,1,5,6}。如果出现这种情况，3,2,1这段就不好弄了，因为按照查找策略，找到2后，会继续“爬坡”，从2之前的部分找，但是2之前的部分没有山顶了，3不是山顶，因为左边没有元素了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: An integers array.&#10;     * @return: return any of peek positions.&#10;     */&#10;    int findPeak(vector&amp;lt;int&amp;gt; A) {&#10;        int ALen = A.size();&#10;        int left = 0;&#10;        int right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (mid &amp;gt; 0 &amp;amp;&amp;amp; mid &amp;lt; ALen - 1 &amp;amp;&amp;amp; A[mid] &amp;gt; A[mid - 1] &amp;amp;&amp;amp; A[mid] &amp;gt; A[mid + 1])&#10;                return mid;&#10;            else if (mid &amp;lt; ALen - 1 &amp;amp;&amp;amp; A[mid] &amp;gt;= A[mid + 1])&#10;                right = mid - 1;&#10;            else if (mid &amp;lt; ALen - 1 &amp;amp;&amp;amp; A[mid] &amp;lt; A[mid + 1])&#10;                left = mid + 1;&#10;            else if (mid &amp;gt; 0 &amp;amp;&amp;amp; A[mid] &amp;gt;= A[mid - 1])&#10;                left = mid + 1;&#10;            else if (mid &amp;gt; 0 &amp;amp;&amp;amp; A[mid] &amp;lt; A[mid - 1])&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="first bad version" >
          <outline text="描述" _note="代码库有1~n个版本，现在确定里边有一个版本是坏的（isBadVersion = true），如果第i个版本是坏的，后面的新版本都是坏的（isBadVersion = true）。之前的好版本isBadVersion = false。现在是从里面找到第一个坏的版本编号。" />
          <outline text="思路" _note="使用二分查找，可以理解为一个数组是0000111111，isBadVersion = true表示1。还是前面说的规律，left表示要查找的数的位置，这里是找1，left就是第一个1的下标。这里需要注意：left初始值为1，这个无所谓的，二分查找的时候，无论left从哪个下标开始（0也好，1页罢），结果一样，最终的left返回的值是一样的，就是应该存储1的位置，也就是第一次出现1的位置。" />
          <outline text="代码" _note="/**&#10; * class VersionControl {&#10; *     public:&#10; *     static bool isBadVersion(int k);&#10; * }&#10; * you can use VersionControl::isBadVersion(k) to judge whether &#10; * the kth code version is bad or not.&#10;*/&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param n: An integers.&#10;     * @return: An integer which is the first bad version.&#10;     */&#10;    int findFirstBadVersion(int n) {&#10;        int left = 1;&#10;        int right = n;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (!VersionControl::isBadVersion(mid))&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return left;&#10;    }&#10;};&#10;" /></outline>
        <outline text="search in rotated sorted array" >
          <outline text="描述" _note="从一个旋转的有序数组中找到给定的数值，数组元素不重复。" />
          <outline text="思路" _note="数组的旋转，可能是原始的样子（有序），还可能是2半各自有序。先通过二分查找找到这个转换点，即A[i]&amp;lt;A[i-1]。然后再对以转换点为分割的两部分各自进行二分查找。" />
          <outline text="代码" _note="class Solution {&#10;    /** &#10;     * param A : an integer ratated sorted array&#10;     * param target :  an integer to be searched&#10;     * return : an integer&#10;     */&#10;public:&#10;    int search(vector&amp;lt;int&amp;gt; &amp;amp;A, int target) {&#10;        int ALen = A.size();&#10;        int pivot = searchPivot(A, ALen);&#10;        if (pivot == -1)&#10;            return bsearch(A, 0, ALen - 1, target);&#10;        int index = bsearch(A, 0, pivot - 1, target);&#10;        if (index == -1)&#10;            return bsearch(A, pivot, ALen - 1, target);&#10;        return index;&#10;    }&#10;    int searchPivot(vector&amp;lt;int&amp;gt;&amp;amp; A, int ALen) {&#10;        int left = 0;&#10;        int right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (mid &amp;gt; 0 &amp;amp;&amp;amp; A[mid] &amp;lt; A[mid - 1])&#10;                return mid;&#10;            if (mid &amp;lt; ALen - 1 &amp;amp;&amp;amp; A[mid] &amp;gt; A[mid + 1])&#10;                return mid + 1;&#10;            if (A[mid] &amp;gt;= A[0])&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;    int bsearch(vector&amp;lt;int&amp;gt;&amp;amp; A, int i, int j, int target) {&#10;        int left = i;&#10;        int right = j;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (A[mid] == target)&#10;                return mid;&#10;            if (A[mid] &amp;lt;= target)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="search for a range" >
          <outline text="描述" _note="有一个有序数组，元素会有重复，从中找出给定元素的下标范围。" />
          <outline text="思路" _note="通过2次二分查找，分别找到下标的“左值”和“右值”。注意里面的规律，left是左边第一个要查找的元素，right是右边第一个要查找的元素。" />
          <outline text="代码" _note="class Solution {&#10;    /** &#10;     *@param A : an integer sorted array&#10;     *@param target :  an integer to be inserted&#10;     *return : a list of length 2, [index1, index2]&#10;     */&#10;public:&#10;    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt; &amp;amp;A, int target) {&#10;        int ALen = A.size();&#10;        vector&amp;lt;int&amp;gt; result(2, -1);&#10;        &#10;        int left = 0;&#10;        int right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (A[mid] &amp;gt;= target)&#10;                right = mid - 1;&#10;            else&#10;                left = mid + 1;&#10;        }&#10;        if (ALen &amp;gt; 0 &amp;amp;&amp;amp; A[left] == target)&#10;            result[0] = left;&#10;            &#10;        left = 0;&#10;        right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (A[mid] &amp;lt;= target)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        if (ALen &amp;gt; 0 &amp;amp;&amp;amp; A[right] == target)&#10;            result[1] = right;&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="find minimum in rotated sorted array ii" >
          <outline text="描述" _note="有一个经过旋转的有序数组，里面的元素可能有重复。从中找到最小的元素。" />
          <outline text="思路" _note="通过二分查找找到转换点pivot，然后min(A[pivot], A[0])就是答案了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param num: the rotated sorted array&#10;     * @return: the minimum number in the array&#10;     */&#10;    int findMin(vector&amp;lt;int&amp;gt; &amp;amp;num) {&#10;        int numLen = num.size();&#10;        int pivot = searchPivot(num, numLen);&#10;        if (pivot == -1)&#10;            return num[0];&#10;        return min(num[0], num[pivot]);&#10;    }&#10;    int searchPivot(vector&amp;lt;int&amp;gt;&amp;amp; A, int ALen) {&#10;        int left = 0;&#10;        int right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (mid &amp;gt; 0 &amp;amp;&amp;amp; A[mid] &amp;lt; A[mid - 1])&#10;                return mid;&#10;            if (mid &amp;lt; ALen - 1 &amp;amp;&amp;amp; A[mid] &amp;gt; A[mid + 1])&#10;                return mid + 1;&#10;            if (A[mid] &amp;gt;= A[0])&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="search in rotated sorted array ii" >
          <outline text="描述" _note="从一个旋转的有序数组中找到给定的数值，数组元素会重复。" />
          <outline text="思路" _note="使用和search in rotated sorted array一样的方法，先找到转换点。然后对转换点2侧的数组二分查找。" />
          <outline text="代码" _note="class Solution {&#10;    /** &#10;     * param A : an integer ratated sorted array and duplicates are allowed&#10;     * param target :  an integer to be search&#10;     * return : a boolean &#10;     */&#10;public:&#10;    bool search(vector&amp;lt;int&amp;gt; &amp;amp;A, int target) {&#10;        int ALen = A.size();&#10;        int pivot = searchPivot(A, ALen);&#10;        if (pivot == -1)&#10;            return bsearch(A, 0, ALen - 1, target);&#10;        bool found = bsearch(A, 0, pivot - 1, target);&#10;        if (!found)&#10;            return bsearch(A, pivot, ALen - 1, target);&#10;        return found;&#10;    }&#10;    int searchPivot(vector&amp;lt;int&amp;gt;&amp;amp; A, int ALen) {&#10;        int left = 0;&#10;        int right = ALen - 1;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (mid &amp;gt; 0 &amp;amp;&amp;amp; A[mid] &amp;lt; A[mid - 1])&#10;                return mid;&#10;            if (mid &amp;lt; ALen - 1 &amp;amp;&amp;amp; A[mid] &amp;gt; A[mid + 1])&#10;                return mid + 1;&#10;            if (A[mid] &amp;gt;= A[0])&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return -1;&#10;    }&#10;    bool bsearch(vector&amp;lt;int&amp;gt;&amp;amp; A, int i, int j, int target) {&#10;        int left = i;&#10;        int right = j;&#10;        while (left &amp;lt;= right) {&#10;            int mid = (left + right) / 2;&#10;            if (A[mid] == target)&#10;                return true;&#10;            if (A[mid] &amp;lt; target)&#10;                left = mid + 1;&#10;            else&#10;                right = mid - 1;&#10;        }&#10;        return false;&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Math &amp;amp; Bit Manipulation" >
        <outline text="flip bits" >
          <outline text="描述" _note="有2个数字，计算其二进制表示的不同的位数。如11111和01110，有2位不同。" />
          <outline text="思路" _note="考虑到不同，把2个数字异或，异或之后只有不同的位置一。然后对异或得到的数字不断移位，判断每一位是否为1，为1则count++。这里需要注意，应该是使用左移，如果右移的话，负数的最高位“移不掉”。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     *@param a, b: Two integer&#10;     *return: An integer&#10;     */&#10;    int bitSwapRequired(int a, int b) {&#10;        int c = a ^ b;&#10;        int count = 0;&#10;        for (int i = 0; i &amp;lt; sizeof(int) * 8; i++) {&#10;            if (c &amp;amp; 0x80000000)&#10;                count++;&#10;            c &amp;lt;&amp;lt;= 1;&#10;        }&#10;        return count;&#10;    }&#10;};&#10;" /></outline>
        <outline text="o1 check power of 2" >
          <outline text="描述" _note="判断给定的数字是否为2的n次幂。" />
          <outline text="思路" _note="一个数字如果是2的n次幂，那么他的二进制表示就只有一个位置1。所以，可以遍历这个数字的每一位，看一下有几个位置1。需要注意，如果是负数，则直接判断其不是2的n次幂。还有一个方法，直接return （n &amp;amp; (n-1)) == 0 ? true : false，原理是如果是2的n次幂，那么n的二进制有1个1，n-1的置1位一定与n的不同；如果不是2的n次幂，那么肯定有大于1个位置1，n-1的置1位一定与n的置1位有相同的。需要注意，第二种方法仍要处理输入为负数或0的情况，比如（0 &amp;amp; -1) == 0。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /*&#10;     * @param n: An integer&#10;     * @return: True or false&#10;     */&#10;    bool checkPowerOf2(int n) {&#10;        if (n &amp;lt;= 0)&#10;            return false;&#10;        return (n &amp;amp; (n - 1)) == 0 ? true : false;&#10;    }&#10;};&#10;" /></outline>
        <outline text="unique paths" >
          <outline text="描述" _note="有一个mxn的格子，从1,1位置走到m,n位置有多少种走法？" />
          <outline text="思路" _note="可以看成一个组合的问题，横向一共走n-1，竖向一共走m-1步，所以一共走m+n-2步，组合数为C(m-1, m+n-2)。这种方法缺点是容易溢出。还可以使用动态规划的方法，dp[m][n]=dp[m-1][n]+dp[m][n-1]，dp[1][i]=1，dp[i][1]=1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param n, m: positive integer (1 &amp;lt;= n ,m &amp;lt;= 100)&#10;     * @return an integer&#10;     */&#10;    /*int uniquePaths(int m, int n) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 1));&#10;        for (int i = 1; i &amp;lt; m; i++) {&#10;            for (int j = 1; j &amp;lt; n; j++) {&#10;                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];&#10;            }&#10;        }&#10;        return dp[m - 1][n - 1];&#10;    }*/&#10;    int C(int n, int m) {&#10;        long double num = 1;&#10;        long double denom = 1;&#10;        for (int i = 1; i &amp;lt;= min(n, m - n); i++) {&#10;            num *= (m - i + 1);&#10;            denom *= i;&#10;        }&#10;        return num / denom;&#10;    }&#10;    int uniquePaths(int m, int n) {&#10;        return C(min(m - 1, n - 1), m + n - 2);&#10;    } &#10;};&#10;" /></outline>
        <outline text="trailing zeros" >
          <outline text="描述" _note="求某个数阶乘所得结果中，尾部连续0的个数。例如，11! = 39916800，尾部连续出现了2个0，所以返回2。" />
          <outline text="思路" _note="这个需要用数学的知识。考虑某个数的阶乘，尾部0的个数代表着这个数可以拆成2x5的个数。也就是说，阶乘运算后的结果，进行分解，得到的2x5的个数就是尾部0的个数。如何得到2x5的个数呢？首先可以确定，分解后的2要多于5，比如，1!有0个2和0个5，2!有1个2和0个5...依次类推，可以发现2的出现次数总是比5多。所以，可以只判断分解后的5的个数即可。对于n!，可以用n/5得出1~n中一共有几个数可以除尽5，这个结果加起来就是分解后的5的个数了！但是需要注意，有的数可以分解成多个5，比如25=5x5，所以我们还需要考虑n/(5x5)。最后得出计算公式，n/5+n/(5x5)+n/(5x5x5) ..." />
          <outline text="代码" _note="class Solution {&#10; public:&#10;    // param n : description of n&#10;    // return: description of return &#10;    long long trailingZeros(long long n) {&#10;        long long count = 0;&#10;        long long divisor = 5;&#10;        while (n / divisor) {&#10;            count += n / divisor;&#10;            divisor *= 5;&#10;        }&#10;        return count;&#10;    }&#10;};&#10;" /></outline>
        <outline text="update bits" >
          <outline text="描述" _note="有2个数，N和M，把M“插入”到N中的指定位置。例如，N=(10000000000)2, M=(10101)2, i=2, j=6，则返回N=(10001010100)2。" />
          <outline text="思路" _note="通过二进制位操作来解决。首先把N中的指定位置清空，使用把1左移然后减1的方式，可以得到一串1，然后再把这一串1左移与N进行与操作即可。然后，把给定的数左移，与清空后的N进行或操作。需要注意的是，第一步清空的时候，如果给定的返回是i~31，即最高位，那么再左移减1就不对了，已经到最左侧了。此时，需要单独对待。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     *@param n, m: Two integer&#10;     *@param i, j: Two bit positions&#10;     *return: An integer&#10;     */&#10;    int updateBits(int n, int m, int i, int j) {&#10;        int mask;&#10;        if (j &amp;lt; 31)&#10;            mask = ~(((1 &amp;lt;&amp;lt; (j - i + 1)) - 1) &amp;lt;&amp;lt; i);&#10;        else&#10;            mask = (1 &amp;lt;&amp;lt; i) - 1;&#10;        return (n &amp;amp; mask) | (m &amp;lt;&amp;lt; i);&#10;    }&#10;};&#10;" /></outline>
        <outline text="unique binary search trees" >
          <outline text="描述" _note="给定一个数字N，求以1,2...N为节点值组成的BST的种类数目。" />
          <outline text="思路" _note="结果是一个卡特兰数，但是一下子想到的是动态规划。设dp[i]为1,2...i为节点组成的BST的种类数目，则dp[i]=sum(dp[j] * dp[i - j - 1])，j&amp;lt;i，表示左侧可能的BST个数乘以右侧的，一共i个元素，左侧有j个，根部一个，则右侧有i-j-1个。终止条件是，dp[0]=1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @paramn n: An integer&#10;     * @return: An integer&#10;     */&#10;    int numTrees(int n) {&#10;        vector&amp;lt;int&amp;gt; count(n + 1, 0);&#10;        count[0] = 1;&#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            for (int j = 0; j &amp;lt; i; j++) {&#10;                count[i] += count[j] * count[i - j -1];&#10;            }&#10;        }&#10;        return count[n];&#10;    }&#10;};&#10;" /></outline>
        <outline text="fast power" >
          <outline text="描述" _note="计算a^n%b，要求O(logn)时间。" />
          <outline text="思路" _note="看到O(logn)应该想到二分查找，在这里，可以先计算half=fastPower(a, b, n/2)，再计算(half*half)%b。如果n不能整除2，则需要再乘上一项，即(half*half*a)%b。这里用到mod数学公式，即(ab)%n=(a%n * b%n)%n。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /*&#10;     * @param a, b, n: 32bit integers&#10;     * @return: An integer&#10;     */&#10;    int fastPower(int a, int b, int n) {&#10;        if (n == 0)&#10;            return 1 % b;&#10;        if (n == 1)&#10;            return a % b;&#10;        &#10;        long half = fastPower(a, b, n / 2);&#10;        long result = (half * half) % b;&#10;        if (n &amp;amp; 1)&#10;            result = (result * a) % b;&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary representation" >
          <outline text="描述" _note="给定一个十进制小数，转换成二进制。" />
          <outline text="思路" _note="分别对小数部分和整数部分转换，对于小数部分，依次乘以2取整数部分，再把小数部分依次乘以2取整数部分...，不断重复，直到小数部分为0，最后把取出的整数部分拼成二进制；对于整数部分，依次除以2，再对商除以2，依次不断重复，直到商为0，最后把余数倒叙排序即可。需要注意的是，c++的double和float无法进行精确计算啊！所以，使用python的decimal库完成。" />
          <outline text="代码" _note="import decimal&#10;&#10;class Solution:&#10;    #@param n: Given a decimal number that is passed in as a string&#10;    #@return: A string&#10;    def binaryRepresentation(self, n):&#10;        # write you code here&#10;        num = decimal.Decimal(n)&#10;        left = int(num)&#10;        right = num - left&#10;        result = ''&#10;        while left:&#10;            result = chr(left % 2 + ord('0')) + result&#10;            left /= 2&#10;        &#10;        if result == '':&#10;            result = '0'&#10;        if right:&#10;            result += '.'&#10;        &#10;        count = 0&#10;        limit = 32&#10;        while right:&#10;            if count &amp;gt;= limit:&#10;                return 'ERROR'&#10;                &#10;            result += chr(int(right * 2) + ord('0'))&#10;            right = right * 2 - int(right * 2)&#10;            count += 1&#10;        &#10;        return result" /></outline>
      </outline>
      <outline text="Greedy" >
        <outline text="single number" >
          <outline text="描述" _note="有奇数个数字，其中只有一个数字出现了一次，其他的都出现了2次，找出这个只出现一次的数。" />
          <outline text="思路" _note="把所有的数字异或，结果就是只出现一次的数字。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;	/**&#10;	 * @param A: Array of integers.&#10;	 * return: The single number.&#10;	 */&#10;    int singleNumber(vector&amp;lt;int&amp;gt; &amp;amp;A) {&#10;        int result = 0;&#10;        for (int i = 0; i &amp;lt; A.size(); i++) {&#10;            result ^= A[i];&#10;        }&#10;        &#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="majority number" >
          <outline text="描述" _note="在一个数组中，有一个数字出现了超过一半的次数，找出这个数字。" />
          <outline text="思路" _note="通过一个count来记录，然后遍历这个数组，如果num[i] == result，则count++；否则，count--。如果count==0，则重新设置result = num[i]。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: The majority number&#10;     */&#10;    int majorityNumber(vector&amp;lt;int&amp;gt; nums) {&#10;        int result;&#10;        int count = 0;&#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            if (count == 0) {&#10;                result = nums[i];&#10;                count++;&#10;            }&#10;            else {&#10;                if (nums[i] == result)&#10;                    count++;&#10;                else&#10;                    count--;&#10;            }&#10;        }&#10;        &#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="gas station" >
          <outline text="描述" _note="有一个环形路线，其中有N个加油站。从加油站i到加油站i+1需要耗费cost[i]，加油站i可以提供gas[i]的油。从N个加油站中选择一个作为起始点，使得可以走完整个环形路线。" />
          <outline text="思路" _note="因为每个加油站提供的油有多有少，所以有可能从某个加油站往下一处行驶时油不够，所以就需要之前存下的油（剩下的油）。有2个规律：1. 如果sum(gas[i]) - sum(cost[i]) &amp;gt;= 0，说明从某个加油站出发，可以走完一圈，否则走不完；2. 如果从某个加油站i出发，到达不了j，因为油不够，则从i～j出发也可能到达不了j，因为从i走是可以存一点油的，都到不了j，从i～j之间就更到不了了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param gas: a vector of integers&#10;     * @param cost: a vector of integers&#10;     * @return: an integer &#10;     */&#10;    int canCompleteCircuit(vector&amp;lt;int&amp;gt; &amp;amp;gas, vector&amp;lt;int&amp;gt; &amp;amp;cost) {&#10;        int count = gas.size();&#10;        int surplus = 0;&#10;        int index = 0;&#10;        int total = 0;&#10;        for (int i = 0; i &amp;lt; count; i++) {&#10;            total += gas[i] - cost[i];&#10;            surplus += gas[i] - cost[i];&#10;            if (surplus &amp;lt; 0) {&#10;                surplus = 0;&#10;                index = i + 1;&#10;            }&#10;        }&#10;        return total &amp;gt;= 0 ? index : -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="largest number" >
          <outline text="描述" _note="给定一个数字数组，将其元素重新排序使得构成的数字最大。例如，[1, 20, 23, 4, 8]组成的最大数字是8423201。" />
          <outline text="思路" _note="贪心的选择最大的数字放到高位，比如描述中的例子，8放在首位。还需要考虑，如3,32,30中，哪个数字应该放在前面？应该是3，因为332构成的最大。可以修改排序的compare函数，compare(int a, int b)，如果“ab”这个数字大于“ba”这个数字，那么就返回true，即a排到前面。“" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     *@param num: A list of non negative integers&#10;     *@return: A string&#10;     */&#10;    string largestNumber(vector&amp;lt;int&amp;gt; &amp;amp;num) {&#10;        sort(num.begin(), num.end(), compare);&#10;        string result;&#10;        for (int i = 0; i &amp;lt; num.size(); i++) {&#10;            if (!result.size() &amp;amp;&amp;amp; num[i] == 0 &amp;amp;&amp;amp; i != num.size() - 1)&#10;                continue;&#10;            result += to_string(num[i]);&#10;        }&#10;        return result;&#10;    }&#10;    struct {&#10;        bool operator()(int a, int b) {&#10;            return a * pow(10, to_string(b).size()) + b &amp;gt; b * pow(10, to_string(a).size()) + a&#10;                ? true : false;&#10;        }&#10;    } compare;&#10;};&#10;" /></outline>
        <outline text="delete digits" >
          <outline text="描述" _note="从一个字符串（数字构成）中删除指定个字符，使得删除后的字符串所表示的数字最小。例如，178542删除4个字符，最小的字符串是12。" />
          <outline text="思路" _note="设删除k个字符，则做k次循环，每次循环从字符串中选择一个字符删除掉。删除的规则是，从字符串头部开始找，找到一个A[i] &amp;gt; A[i + 1]，则删除A[i]，找不到的话，则删除A[A.size() - 1]，即最后一个字符。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     *@param A: A positive integer which has N digits, A is a string.&#10;     *@param k: Remove k digits.&#10;     *@return: A string&#10;     */&#10;    string DeleteDigits(string A, int k) {&#10;        string result = A;&#10;        for (int i = 0; i &amp;lt; k; i++) {&#10;            removeDigit(result);&#10;        }&#10;        for (int i = 0; i &amp;lt; result.size() - 1; i++) {&#10;            if (result[i] != '0')&#10;                return result.substr(i, result.size() - i);&#10;        }&#10;        return result;        &#10;    }&#10;    &#10;    void removeDigit(string&amp;amp; A) {&#10;        for (int i = 0; i &amp;lt; A.size() - 1; i++) {&#10;            if (A[i] &amp;gt; A[i + 1]) {&#10;                A.erase(i, 1);&#10;                return;&#10;            }&#10;        }&#10;        A.erase(A.size() - 1, 1);&#10;    }&#10;};&#10;" /></outline>
        <outline text="jump game" >
          <outline text="描述" _note="有一个非负数组，每一个数字代表可以往下走的最大步数，问给定的数组能否从头走到尾。" />
          <outline text="思路" _note="使用一个surplus（剩余可走步数）记录当前位置可以往后走的最大步数，只有在每一步的时候surplus都大于0，就说明可以走到尾部。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: A list of integers&#10;     * @return: The boolean answer&#10;     */&#10;    bool canJump(vector&amp;lt;int&amp;gt; A) {&#10;        int surplus = 1;&#10;        for (int i = 0; i &amp;lt; A.size(); i++) {&#10;            surplus -= 1;&#10;            if (surplus &amp;lt; A[i])&#10;                surplus = A[i];&#10;            if (surplus == 0)&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;};" /></outline>
        <outline text="next permutation" >
          <outline text="描述" _note="求给定排列的下一个排列。" />
          <outline text="思路" _note="从后往前找到第一个满足A[i] &amp;lt; A[i + 1]的关系，然后再从后往前找到一个A[j] &amp;gt; A[i] &amp;amp;&amp;amp; j &amp;gt; i，交换A[i]和A[j]，reverse i+1及其后面的数。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: An array of integers&#10;     * @return: An array of integers that's next permuation&#10;     */&#10;    vector&amp;lt;int&amp;gt; nextPermutation(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        for (int i = nums.size() - 2; i &amp;gt;= 0; i--) {&#10;            if (nums[i] &amp;lt; nums[i + 1]) {&#10;                int j = nums.size() - 1;&#10;                while (j &amp;gt; i) {&#10;                    if (nums[j] &amp;gt; nums[i]) {&#10;                        swap(nums, i, j);&#10;                        break;&#10;                    }&#10;                    j--;&#10;                }&#10;                reverse(nums.begin() + i + 1, nums.end());&#10;                return nums;&#10;            }   &#10;        }&#10;        reverse(nums.begin(), nums.end());&#10;        return nums;&#10;    }&#10;    void swap(vector&amp;lt;int&amp;gt;&amp;amp; v, int i, int j) {&#10;        int tmp = v[i];&#10;        v[i] = v[j];&#10;        v[j] = tmp;&#10;    }&#10;};&#10;" /></outline>
        <outline text="- jump game ii" >
          <outline text="描述" _note="给定一个数组，数组的每个元素代表可以往后走的步数，求最少几跳可以到达最后一个元素。" />
          <outline text="思路" _note="遍历数组，每次都求出截止到当前元素可以跳的最远位置curr = max(curr, i + A[i])。如果i &amp;gt; curr，说明0~i-1的任何元素都不能一次跳到i的位置，即返回-1。如果i &amp;gt; last，也就是i == last + 1，此时终于走出了上一次跳的范围，可以进行下一跳了，即last = curr，其中curr是last（0~i - 1）可以跳到的位置。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: A list of lists of integers&#10;     * @return: An integer&#10;     */&#10;    int jump(vector&amp;lt;int&amp;gt; A) {&#10;        int curr = 0;&#10;        int last = 0;&#10;        int result = 0;&#10;        for (int i = 0; i &amp;lt; A.size(); i++) {&#10;            if (i &amp;gt; curr)&#10;                return -1;&#10;            if (i &amp;gt; last) {&#10;                last = curr;&#10;                result++;&#10;            }&#10;            curr = max(curr, i + A[i]);&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="single number iii" >
          <outline text="描述" _note="有2n+2个数字，其中有n个数字出现2次，有2个不同的数字各出现一次，找不这2个不同的数字。" />
          <outline text="思路" _note="先把所有的数字异或，得到一个数字，然后在得到的这个数字二进制表示中找到一个为1的位（随便找一位就可以，假设这一位是第x位，这个位可以区分要找的折2个数字，其他数字异或为0）。把所有数字x位为1的一起异或，为0的一起异或，这样会得到2个数，即为要找的数字。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A : An integer array&#10;     * @return : Two integers&#10;     */&#10;    vector&amp;lt;int&amp;gt; singleNumberIII(vector&amp;lt;int&amp;gt; &amp;amp;A) {&#10;        int num = 0;&#10;        for (int i = 0; i &amp;lt; A.size(); i++) {&#10;            num ^= A[i];&#10;        }&#10;        &#10;        int diff = 1;&#10;        while (!(diff &amp;amp; num)) {&#10;            diff &amp;lt;&amp;lt;= 1;&#10;        }&#10;        &#10;        vector&amp;lt;int&amp;gt; result(2, 0);&#10;        for (int i = 0; i &amp;lt; A.size(); i++) {&#10;            if (diff &amp;amp; A[i])&#10;                result[0] ^= A[i];&#10;            else&#10;                result[1] ^= A[i];&#10;        }&#10;        sort(result.begin(), result.end());&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="single number ii" >
          <outline text="描述" _note="有一个数组，所有的数字都出现了3次，只有一个数字出现了1次，找出这个数字。" />
          <outline text="思路" _note="把所有数字的各个位加起来，肯定每一位都是&amp;gt;=3，然后把每一位都mod3，得到的就是要找的数字。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;	/**&#10;	 * @param A : An integer array&#10;	 * @return : An integer &#10;	 */&#10;    int singleNumberII(vector&amp;lt;int&amp;gt; &amp;amp;A) {&#10;        const int limit = 32;&#10;        vector&amp;lt;int&amp;gt; num(limit, 0);&#10;        int result = 0;&#10;        for (int i = 0; i &amp;lt; limit; i++) {&#10;            for (int j = 0; j &amp;lt; A.size(); j++) {&#10;                num[i] += (bool)(A[j] &amp;amp; (1 &amp;lt;&amp;lt; i));&#10;            }&#10;            result |= (num[i] % 3) &amp;lt;&amp;lt; i;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="majority number iii" >
          <outline text="描述" _note="求在数组中出现次数超过1/k的数。" />
          <outline text="思路" _note="和majority number ii思路一样，只是我们需要定义k-1个num变量和k-1个count变量，所以使用map存储，key为num，value为出现次数count。同样使用把k个数字合并抵消的方式。最后map里的key即使答案候选集，所以还是需要一次遍历精确计算出最终的答案。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @param k: As described&#10;     * @return: The majority number&#10;     */&#10;    int majorityNumber(vector&amp;lt;int&amp;gt; nums, int k) {&#10;        map&amp;lt;int, int&amp;gt; counters;&#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            if (counters.find(nums[i]) != counters.end())&#10;                counters[nums[i]]++;&#10;            else if (counters.size() &amp;lt; k - 1)&#10;                counters[nums[i]] = 1;&#10;            else {&#10;                for (map&amp;lt;int, int&amp;gt;::iterator i = counters.begin(); i != counters.end(); ) {&#10;                    i-&amp;gt;second--;&#10;                    if (i-&amp;gt;second == 0)&#10;                        counters.erase(i++);&#10;                    else&#10;                        i++;&#10;                }&#10;            }&#10;        }&#10;        for (map&amp;lt;int, int&amp;gt;::iterator i = counters.begin(); i != counters.end(); i++)&#10;            i-&amp;gt;second = 0;&#10;        &#10;        int maxCount = 0;&#10;        int result;&#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            if (counters.find(nums[i]) != counters.end()) {&#10;                counters[nums[i]]++;            &#10;                if (counters[nums[i]] &amp;gt; maxCount) {&#10;                    maxCount = counters[nums[i]];&#10;                    result = nums[i];&#10;                }&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="majority number ii" >
          <outline text="描述" _note="求在数组中出现次数超过1/2的数。" />
          <outline text="思路" _note="使用和majority number类似的方法，“合并抵消”。使用2个变量num1, num2和相应的计数器，count1, count2。遍历数组，如果num[i]和num1和num2三者都各不相同，则count1--,count2--。如果num1或者num2为0，则把num[i]存入进去，相应的countX++。最后，不断的合并抵消，num1和num2中有一个即为答案。最后还需要遍历一次数组，精确计算出num1和num2各出现多少次。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: The majority number occurs more than 1/3.&#10;     */&#10;    int majorityNumber(vector&amp;lt;int&amp;gt; nums) {&#10;        int num1 = INT_MIN;&#10;        int num2 = INT_MIN;&#10;        int count1 = 0;&#10;        int count2 = 0;&#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            if (nums[i] == num1)&#10;                count1++;&#10;            else if (nums[i] == num2)&#10;                count2++;&#10;            else if (count1 == 0) {&#10;                num1 = nums[i];&#10;                count1++;&#10;            }&#10;            else if (count2 == 0) {&#10;                num2 = nums[i];&#10;                count2++;&#10;            }&#10;            else {&#10;                count1--;&#10;                count2--;&#10;            }&#10;        }&#10;        &#10;        count1 = 0;&#10;        count2 = 0;&#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            if (nums[i] == num1)&#10;                count1++;&#10;            if (nums[i] == num2)&#10;                count2++;&#10;        }&#10;        &#10;        return count1 &amp;gt; count2 ? num1 : num2;&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Linked List" >
        <outline text="remove nth node from end of list" >
          <outline text="描述" _note="删除链表倒数第k个结点。" />
          <outline text="思路" _note="使用快慢指针，需要注意，可能删除链表的第一个节点，所以需要使用辅助头结点dummy。还可能删除的结点不存在，比如链表长度为3，删除倒数第9个结点，此时不做删除操作直接返回。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @param n: An integer.&#10;     * @return: The head of linked list.&#10;     */&#10;    ListNode *removeNthFromEnd(ListNode *head, int n) {&#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        &#10;        ListNode* slow = &amp;amp;dummy;&#10;        ListNode* fast = &amp;amp;dummy;&#10;        &#10;        for (int i = 0; i &amp;lt;= n; i++) {&#10;            if (fast == NULL)&#10;                return head;&#10;            fast = fast-&amp;gt;next;&#10;        }&#10;        &#10;        while (fast != NULL) {&#10;            slow = slow-&amp;gt;next;&#10;            fast = fast-&amp;gt;next;&#10;        }&#10;        ListNode* tmp = slow-&amp;gt;next-&amp;gt;next;&#10;        delete slow-&amp;gt;next;&#10;        slow-&amp;gt;next = tmp;&#10;        return dummy.next;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
        <outline text="merge two sorted lists" >
          <outline text="描述" _note="合并2个有序的链表。" />
          <outline text="思路" _note="使用一个dummy结点，curr-&amp;gt;next存放来自有序链表的结点，不断遍历2个链表并把值小的结点放到curr-&amp;gt;next。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param ListNode l1 is the head of the linked list&#10;     * @param ListNode l2 is the head of the linked list&#10;     * @return: ListNode head of linked list&#10;     */&#10;    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {&#10;        ListNode dummy;&#10;        ListNode* curr = &amp;amp;dummy;&#10;        ListNode* p = l1;&#10;        ListNode* q = l2;&#10;        &#10;        while (p != NULL || q != NULL) {&#10;            if (p != NULL &amp;amp;&amp;amp; q != NULL) {&#10;                if (p-&amp;gt;val &amp;lt; q-&amp;gt;val) {&#10;                    curr-&amp;gt;next = p;&#10;                    p = p-&amp;gt;next;&#10;                }&#10;                else {&#10;                    curr-&amp;gt;next = q;&#10;                    q = q-&amp;gt;next;                &#10;                }&#10;            }&#10;            else if (p != NULL) {&#10;                curr-&amp;gt;next = p;&#10;                p = p-&amp;gt;next;&#10;            }&#10;            else if (q != NULL) {&#10;                curr-&amp;gt;next = q;&#10;                q = q-&amp;gt;next;&#10;            }&#10;            curr = curr-&amp;gt;next;&#10;        }&#10;        &#10;        return dummy.next;&#10;    }&#10;};&#10;" /></outline>
        <outline text="remove duplicates from sorted list" >
          <outline text="描述" _note="删除有序链表中的重复值，只保留一个。" />
          <outline text="思路" _note="使用一个dummy头结点，curr指向dummy，curr-&amp;gt;next存放不重复的一个结点。不断的对输入链表相邻A[i]，A[i+1]比较，如果&#10;A[i] == A[i+1]，则删除A[i]，继续比较A[i+1]和A[i+2]；如果A[i] != A[i+1]，则把A[i]加入到curr-&amp;gt;next。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: head node&#10;     */&#10;    ListNode *deleteDuplicates(ListNode *head) {&#10;        ListNode dummy;&#10;        ListNode* curr = &amp;amp;dummy;&#10;        ListNode* p = head;&#10;        while (p != NULL &amp;amp;&amp;amp; p-&amp;gt;next != NULL) {&#10;            if (p-&amp;gt;val == p-&amp;gt;next-&amp;gt;val) {&#10;                ListNode* tmp = p;&#10;                p = p-&amp;gt;next;&#10;                delete tmp;&#10;            }&#10;            else {&#10;                curr-&amp;gt;next = p;&#10;                curr = curr-&amp;gt;next;&#10;                p = p-&amp;gt;next;&#10;            }&#10;        }&#10;        curr-&amp;gt;next = p;&#10;        return dummy.next;&#10;    }&#10;};&#10;" /></outline>
        <outline text="partition list" >
          <outline text="描述" _note="对链表执行类似quicksort的partition操作，小于给定元素x，则放到左边，否则放到右边。左边的元素要保持在原始链表中的顺序，右边同样。" />
          <outline text="思路" _note="使用2个dummy头结点，分别是left和right，最后再把left和right连接起来。需要注意，right的最后一个结点的next要指向NULL，因为在原始的链表中该结点可能指向某个结点，这样就会有环了。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @param x: an integer&#10;     * @return: a ListNode &#10;     */&#10;    ListNode *partition(ListNode *head, int x) {&#10;        ListNode left;&#10;        ListNode right;&#10;        ListNode* p = head;&#10;        ListNode* currLeft = &amp;amp;left;&#10;        ListNode* currRight = &amp;amp;right;&#10;        while (p != NULL) {&#10;            if (p-&amp;gt;val &amp;lt; x) {&#10;                currLeft-&amp;gt;next = p;&#10;                currLeft = currLeft-&amp;gt;next;&#10;            }&#10;            else {&#10;                currRight-&amp;gt;next = p;&#10;                currRight = currRight-&amp;gt;next;&#10;            }&#10;            p = p-&amp;gt;next;&#10;        }&#10;        currLeft-&amp;gt;next = right.next;&#10;        currRight-&amp;gt;next = NULL;//important&#10;        return left.next;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
        <outline text="reverse linked list" >
          <outline text="描述" _note="反转链表。" />
          <outline text="思路" _note="使用一个prev，最开始指向NULL，然后遍历链表，不断的把结点指向prev，再移动prev。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * &#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; * &#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: The new head of reversed linked list.&#10;     */&#10;    ListNode *reverse(ListNode *head) {&#10;        ListNode* prev = NULL;&#10;        ListNode* p = head;&#10;        &#10;        while (p != NULL) {&#10;            ListNode* next = p-&amp;gt;next;&#10;            p-&amp;gt;next = prev;&#10;            prev = p;&#10;            p = next;&#10;        }&#10;        return prev;&#10;    }&#10;};&#10;" /></outline>
        <outline text="rotate list" >
          <outline text="描述" _note="反转链表，如1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL，给定k=2，则将后2个结点（3, 4)反转到链表前面，3-&amp;gt;4-&amp;gt;1-&amp;gt;2-&amp;gt;NULL。" />
          <outline text="思路" _note="先找到倒数第k+1个结点，使用快慢指针即可。还要使用dummy头结点，因为倒数第k+1个结点可能是头结点的前面的结点，即链表有k个结点。然后A[k+1]-&amp;gt;next = NULL，断开链表。快指针走到链表尾部，next=dummy.next。" />
          <outline text="代码" _note="/**&#10; * Definition for singly-linked list.&#10; * struct ListNode {&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int x) : val(x), next(NULL) {}&#10; * };&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: the list&#10;     * @param k: rotate to the right k places&#10;     * @return: the list after rotation&#10;     */&#10;    ListNode *rotateRight(ListNode *head, int k) {&#10;        k = k % listLen(head);&#10;        &#10;        if (k &amp;lt;= 0 || head == NULL)&#10;            return head;&#10;            &#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        ListNode* slow = &amp;amp;dummy;&#10;        ListNode* fast = &amp;amp;dummy;&#10;        for (int i = 0; i &amp;lt; k; i++) {&#10;            if (fast == NULL)&#10;                return head;&#10;            fast = fast-&amp;gt;next;&#10;        }&#10;        while (fast-&amp;gt;next != NULL) {&#10;            fast = fast-&amp;gt;next;&#10;            slow = slow-&amp;gt;next;&#10;        }&#10;        &#10;        ListNode* next = slow-&amp;gt;next;&#10;        slow-&amp;gt;next = NULL;&#10;        if (next == dummy.next || next == NULL)&#10;            return dummy.next;&#10;        fast-&amp;gt;next = dummy.next;&#10;        return next;&#10;    }&#10;    int listLen(ListNode* head) {&#10;        if (head == NULL)&#10;            return -1;&#10;        int count = 0;&#10;        ListNode* p = head;&#10;        while (p != NULL) {&#10;            count++;&#10;            p = p-&amp;gt;next;&#10;        }&#10;        return count;&#10;    }&#10;};&#10;" /></outline>
        <outline text="convert sorted list to binary search tree" >
          <outline text="描述" _note="将一个有序单链表转换成height balanced BST。" />
          <outline text="思路" _note="找到单链表的中间结点mid，即BST的root。同理，在0~mid-1中找到中间结点，即root-&amp;gt;left；mid+1~length-1中找到中间结点，即root-&amp;gt;right。以此类推，递归执行。在超时代码中，找到mid是使用遍历的方法，每次找指定的mid，都要从单链表中遍历，会超时。为了解决这个问题，不使用遍历方法找mid，而是是buildTreeFromList中传入单链表的引用，即curr，每次构建好一个TreeNode，就curr = curr-&amp;gt;next。构建Tree的方式是先构建左子树，再构建根，再构建右子树，刚好和curr的移动次序一致。" />
          <outline text="超时代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: a tree node&#10;     */&#10;    TreeNode *sortedListToBST(ListNode *head) {&#10;        int length = listLen(head);&#10;        buildTreeFromList(head, 0, length - 1);&#10;    }&#10;    TreeNode* buildTreeFromList(ListNode* head, int left, int right) {&#10;        if (left &amp;gt; right)&#10;            return NULL;&#10;        &#10;        int mid = (left + right) / 2;&#10;        ListNode* p = head;&#10;        for (int i = 0; i &amp;lt; mid; i++)&#10;            p = p-&amp;gt;next;&#10;        TreeNode* root = new TreeNode(p-&amp;gt;val);&#10;        root-&amp;gt;left = buildTreeFromList(head, left, mid - 1);&#10;        root-&amp;gt;right = buildTreeFromList(head, mid + 1, right);&#10;        return root;&#10;    }&#10;    int listLen(ListNode* head) {&#10;        int count = 0;&#10;        while (head != NULL) {&#10;            count++;&#10;            head = head-&amp;gt;next;&#10;        }&#10;        return count;&#10;    }&#10;};&#10;&#10;&#10;" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: a tree node&#10;     */&#10;    TreeNode *sortedListToBST(ListNode *head) {&#10;        int length = listLen(head);&#10;        buildTreeFromList(head, 0, length - 1);&#10;    }&#10;    TreeNode* buildTreeFromList(ListNode*&amp;amp; curr, int left, int right) {&#10;        if (left &amp;gt; right)&#10;            return NULL;&#10;        &#10;        int mid = (left + right) / 2;&#10;        TreeNode* leftTree = buildTreeFromList(curr, left, mid - 1);&#10;        TreeNode* root = new TreeNode(curr-&amp;gt;val);&#10;        curr = curr-&amp;gt;next;&#10;        TreeNode* rightTree = buildTreeFromList(curr, mid + 1, right);&#10;        root-&amp;gt;left = leftTree;&#10;        root-&amp;gt;right = rightTree;&#10;        return root;&#10;    }&#10;    int listLen(ListNode* head) {&#10;        int count = 0;&#10;        while (head != NULL) {&#10;            count++;&#10;            head = head-&amp;gt;next;&#10;        }&#10;        return count;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
        <outline text="copy list with random pointer" >
          <outline text="描述" _note="深拷贝一个带random指针的链表。" />
          <outline text="思路" _note="分三步：在原始链表的每一个结点后面都复制一个结点；遍历新链表，设置新加结点的random指针，使其指向前面结点的next；拆分2个链表。" />
          <outline text="代码" _note="/**&#10; * Definition for singly-linked list with a random pointer.&#10; * struct RandomListNode {&#10; *     int label;&#10; *     RandomListNode *next, *random;&#10; *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}&#10; * };&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The head of linked list with a random pointer.&#10;     * @return: A new head of a deep copy of the list.&#10;     */&#10;    RandomListNode *copyRandomList(RandomListNode *head) {&#10;        copyList(head);&#10;        copyRandom(head);&#10;        return extractCopyedList(head);&#10;    }&#10;    void copyList(RandomListNode* head) {&#10;        RandomListNode* curr = head;&#10;        while (curr != NULL) {&#10;            RandomListNode* tmp = curr-&amp;gt;next;&#10;            curr-&amp;gt;next = new RandomListNode(curr-&amp;gt;label);&#10;            curr-&amp;gt;next-&amp;gt;next = tmp;&#10;            curr = curr-&amp;gt;next-&amp;gt;next;&#10;        }&#10;    }&#10;    void copyRandom(RandomListNode* head) {&#10;        RandomListNode* curr = head;&#10;        while (curr != NULL) {&#10;            if (curr-&amp;gt;random != NULL)&#10;                curr-&amp;gt;next-&amp;gt;random = curr-&amp;gt;random-&amp;gt;next;&#10;            curr = curr-&amp;gt;next-&amp;gt;next;&#10;        }&#10;    }&#10;    RandomListNode* extractCopyedList(RandomListNode* head) {&#10;        RandomListNode dummy;&#10;        RandomListNode* p = head;&#10;        RandomListNode* q = &amp;amp;dummy;&#10;        while (p != NULL) {//important&#10;            q-&amp;gt;next = p-&amp;gt;next;&#10;            p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next;&#10;            p = p-&amp;gt;next;&#10;            q = q-&amp;gt;next;&#10;        }&#10;        return dummy.next;&#10;    }&#10;};&#10;" /></outline>
        <outline text="linked list cycle" >
          <outline text="描述" _note="判断链表中是否有环。" />
          <outline text="思路" _note="使用快慢指针，快指针每次都2步，慢指针每次都1步，如果二者相遇，则有环。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: True if it has a cycle, or false&#10;     */&#10;    bool hasCycle(ListNode *head) {&#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        ListNode* slow = &amp;amp;dummy;&#10;        ListNode* fast = &amp;amp;dummy;&#10;        do {&#10;            slow = slow-&amp;gt;next;&#10;            fast = fast-&amp;gt;next;&#10;            if (fast != NULL)&#10;                fast = fast-&amp;gt;next;&#10;            else&#10;                return false;&#10;            if (slow == fast)&#10;                return true;&#10;        } while (fast != NULL);&#10;        return false;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
        <outline text="reorder list" >
          <outline text="描述" _note="重排链表，如1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;null，则返回1-&amp;gt;4-&amp;gt;2-&amp;gt;3-&amp;gt;null，即第一个元素和最后一个元素连接，第二个元素和倒数第二个元素连接，以此类推。" />
          <outline text="思路" _note="先把链表切分成两部分，把第二部分链表反转，再和第一部分合并。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: void&#10;     */&#10;    void reorderList(ListNode *head) {&#10;        ListNode* left;&#10;        ListNode* right;&#10;        splitList(head, left, right);&#10;        reverseList(right);&#10;        head = mergeList(left, right);&#10;    }&#10;    void splitList(ListNode* head, ListNode*&amp;amp; left, ListNode*&amp;amp; right) {&#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        left = &amp;amp;dummy;&#10;        right = &amp;amp;dummy;&#10;        while (right != NULL &amp;amp;&amp;amp; right-&amp;gt;next != NULL) {&#10;            left = left-&amp;gt;next;&#10;            right = right-&amp;gt;next;&#10;            if (right)&#10;                right = right-&amp;gt;next;&#10;        }&#10;        right = left-&amp;gt;next;&#10;        left-&amp;gt;next = NULL;&#10;        left = head;&#10;    }&#10;    void reverseList(ListNode*&amp;amp; head) {&#10;        ListNode* prev = NULL;&#10;        ListNode* curr = head;&#10;        while (curr != NULL) {&#10;            ListNode* next = curr-&amp;gt;next;&#10;            curr-&amp;gt;next = prev;&#10;            prev = curr;&#10;            curr = next;&#10;        }&#10;        head = prev;&#10;    }&#10;    ListNode* mergeList(ListNode* left, ListNode* right) {&#10;        ListNode dummy;&#10;        ListNode* curr = &amp;amp;dummy;&#10;        ListNode* p = left;&#10;        ListNode* q = right;&#10;        while (p != NULL || q != NULL) {&#10;            if (p != NULL) {&#10;                curr-&amp;gt;next = p;&#10;                curr = p;&#10;                p = p-&amp;gt;next;&#10;            }&#10;            if (q != NULL) {&#10;                curr-&amp;gt;next = q;&#10;                curr = q;&#10;                q = q-&amp;gt;next;&#10;            }&#10;        }&#10;        return dummy.next;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
        <outline text="sort list" >
          <outline text="描述" _note="链表排序，要求O(nlogn)时间。" />
          <outline text="思路" _note="使用快速排序或归并排序。在lintcode中快速排序会超时。" />
          <outline text="超时代码（quicksort）" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: You should return the head of the sorted linked list,&#10;                    using constant space complexity.&#10;     */&#10;    ListNode *sortList(ListNode *head) {&#10;        return quicksort(head);&#10;    }&#10;    // QuickSort&#10;    // Return newHead of sorted list&#10;    ListNode* quicksort(ListNode* head) {&#10;        if (head == NULL)&#10;            return NULL;&#10;        ListNode* L1;&#10;        ListNode* L2;&#10;        ListNode* pivot = partition(head, L1, L2);&#10;        ListNode* newHead = quicksort(L1);&#10;    &#10;        //timeout&#10;        ListNode* p = newHead;&#10;        if (p != NULL) {&#10;            while (p-&amp;gt;next != NULL)&#10;                p = p-&amp;gt;next;&#10;            p-&amp;gt;next = pivot;&#10;        }&#10;        else&#10;            newHead = pivot;&#10;            &#10;        pivot-&amp;gt;next = quicksort(L2);&#10;        return newHead;        &#10;    }&#10;    ListNode* partition(ListNode* head, ListNode*&amp;amp; L1, ListNode*&amp;amp; L2) {&#10;        ListNode* pivot = head;&#10;        ListNode* curr = head-&amp;gt;next;&#10;        ListNode leftList, rightList;&#10;        ListNode* p = &amp;amp;leftList;&#10;        ListNode* q = &amp;amp;rightList;&#10;        while (curr != NULL) {&#10;            if (curr-&amp;gt;val &amp;lt;= pivot-&amp;gt;val) {&#10;                p-&amp;gt;next = curr;&#10;                p = p-&amp;gt;next;&#10;            }&#10;            else {&#10;                q-&amp;gt;next = curr;&#10;                q = q-&amp;gt;next;&#10;            }&#10;            curr = curr-&amp;gt;next;&#10;        }&#10;        p-&amp;gt;next = NULL;&#10;        q-&amp;gt;next = NULL;&#10;        L1 = leftList.next;&#10;        L2 = rightList.next;&#10;        return pivot;&#10;    }&#10;};&#10;&#10;&#10;" />
          <outline text="代码（mergesort）" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: You should return the head of the sorted linked list,&#10;                    using constant space complexity.&#10;     */&#10;    ListNode *sortList(ListNode *head) {&#10;        return mergesort(head);&#10;    }&#10;    ListNode* mergesort(ListNode* head) {&#10;        if (head == NULL || head-&amp;gt;next == NULL)&#10;            return head;&#10;            &#10;        ListNode* mid = splitList(head);&#10;        ListNode* left = mergesort(head);&#10;        ListNode* right = mergesort(mid);&#10;        return mergeList(left, right);&#10;    }&#10;    ListNode* splitList(ListNode* head) {&#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        ListNode* slow = &amp;amp;dummy;&#10;        ListNode* fast = &amp;amp;dummy;&#10;        while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {&#10;            slow = slow-&amp;gt;next;&#10;            fast = fast-&amp;gt;next;&#10;            if (fast != NULL)&#10;                fast = fast-&amp;gt;next;&#10;        }&#10;        ListNode* mid = slow-&amp;gt;next;&#10;        slow-&amp;gt;next = NULL;&#10;        return mid;&#10;    }&#10;    ListNode* mergeList(ListNode* left, ListNode* right) {&#10;        ListNode dummy;&#10;        ListNode* curr = &amp;amp;dummy;&#10;        ListNode* p = left;&#10;        ListNode* q = right;&#10;        while(p != NULL || q != NULL) {&#10;            if (p != NULL &amp;amp;&amp;amp; q != NULL) {&#10;                if (p-&amp;gt;val &amp;lt; q-&amp;gt;val) {&#10;                    curr-&amp;gt;next = p;&#10;                    p = p-&amp;gt;next;&#10;                }&#10;                else {&#10;                    curr-&amp;gt;next = q;&#10;                    q = q-&amp;gt;next;&#10;                }&#10;            }&#10;            else if (p != NULL) {&#10;                curr-&amp;gt;next = p;&#10;                p = p-&amp;gt;next;&#10;            }&#10;            else if (q != NULL) {&#10;                curr-&amp;gt;next = q;&#10;                q = q-&amp;gt;next;&#10;            }&#10;            curr = curr-&amp;gt;next;&#10;        }&#10;        return dummy.next;&#10;    }&#10;    &#10;};&#10;&#10;&#10;" /></outline>
        <outline text="add two numbers" >
          <outline text="描述" _note="两个链表相加，7-&amp;gt;1-&amp;gt;6 + 5-&amp;gt;9-&amp;gt;2 = 617 + 295 = 2-&amp;gt;1-&amp;gt;9。" />
          <outline text="思路" _note="需要有一个进位变量carry，每次相加后都把进位存储到carry中，最后遍历完链表后，判断carry是否大于0，如果大于0&#10;，则新建一个结点。" />
          <outline text="代码" _note="/**&#10; * Definition for singly-linked list.&#10; * struct ListNode {&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int x) : val(x), next(NULL) {}&#10; * };&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param l1: the first list&#10;     * @param l2: the second list&#10;     * @return: the sum list of l1 and l2 &#10;     */&#10;    ListNode *addLists(ListNode *l1, ListNode *l2) {&#10;        ListNode dummy;&#10;        ListNode* curr = &amp;amp;dummy;&#10;        ListNode* p = l1;&#10;        ListNode* q = l2;&#10;        int carry = 0;&#10;        while (p != NULL || q != NULL) {&#10;            int num = carry;&#10;            if (p != NULL) {&#10;                num += p-&amp;gt;val;&#10;                p = p-&amp;gt;next;&#10;            }&#10;            if (q != NULL) {&#10;                num += q-&amp;gt;val;&#10;                q = q-&amp;gt;next;&#10;            }&#10;                &#10;            curr-&amp;gt;next = new ListNode(num % 10);&#10;            carry = num / 10;&#10;            curr = curr-&amp;gt;next;&#10;        }&#10;        if (carry)&#10;            curr-&amp;gt;next = new ListNode(carry);&#10;        return dummy.next;&#10;    }&#10;};&#10;" /></outline>
        <outline text="nth to last node in list" >
          <outline text="描述" _note="返回链表的倒数第n个结点。" />
          <outline text="思路" _note="使用快慢指针，快指针先走n个结点。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @param n: An integer.&#10;     * @return: Nth to last node of a singly linked list. &#10;     */&#10;    ListNode *nthToLast(ListNode *head, int n) {&#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        ListNode* slow = &amp;amp;dummy;&#10;        ListNode* fast = &amp;amp;dummy;&#10;        for (int i = 0; i &amp;lt; n; i++) {&#10;            fast = fast-&amp;gt;next;&#10;        }&#10;        while (fast != NULL) {&#10;            slow = slow-&amp;gt;next;&#10;            fast = fast-&amp;gt;next;&#10;        }&#10;        return slow;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
        <outline text="remove duplicates from sorted list ii" >
          <outline text="描述" _note="从链表中删除重复的元素，1-&amp;gt;2-&amp;gt;2-&amp;gt;3-&amp;gt;NULL，则变为1-&amp;gt;3-&amp;gt;NULL。" />
          <outline text="思路" _note="遍历链表，然后判断当前节点是否与前一个或后一个相等，如果相等则删除。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution{&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: head node&#10;     */&#10;    ListNode * deleteDuplicates(ListNode *head) {&#10;        ListNode dummy;&#10;        ListNode* curr = &amp;amp;dummy;&#10;        ListNode* p = head;&#10;        int prev = INT_MIN;&#10;        while (p != NULL) {&#10;            ListNode* next = p-&amp;gt;next;&#10;            if (p-&amp;gt;val != prev &amp;amp;&amp;amp; (next == NULL || p-&amp;gt;val != next-&amp;gt;val)) {&#10;                prev = p-&amp;gt;val;&#10;                curr-&amp;gt;next = p;&#10;                curr = curr-&amp;gt;next;&#10;                p = p-&amp;gt;next;&#10;            }&#10;            else {&#10;                prev = p-&amp;gt;val;&#10;                delete p;&#10;                p = next;&#10;            }&#10;        }&#10;        curr-&amp;gt;next = NULL;&#10;        return dummy.next;&#10;    }&#10;};&#10;" /></outline>
        <outline text="reverse linked list ii" >
          <outline text="描述" _note="反转链表的指定连续区域。" />
          <outline text="思路" _note="先遍历到要反转的位置，遍历的同时，记录prev和curr，把curr反转，然后再prev-&amp;gt;next = curr。在反转curr的时候，要传入一个反转的结点个数，反转第一个结点时，记录下该结点tmp，最后需要将tmp-&amp;gt;next连接到链表后面无需反转的部分。" />
          <outline text="代码" _note="/**&#10; * Definition of singly-linked-list:&#10; * &#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *        this-&amp;gt;val = val;&#10; *        this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The head of linked list.&#10;     * @param m: The start position need to reverse.&#10;     * @param n: The end position need to reverse.&#10;     * @return: The new head of partial reversed linked list.&#10;     */&#10;    ListNode *reverseBetween(ListNode *head, int m, int n) {&#10;        ListNode dummy;&#10;        dummy.next = head;&#10;        ListNode* prev = &amp;amp;dummy;&#10;        ListNode* curr = head;&#10;        for (int i = 1; curr != NULL; i++) {&#10;            if (i &amp;gt;= m &amp;amp;&amp;amp; i &amp;lt;= n) {&#10;                prev-&amp;gt;next = reverseList(curr, n - m + 1);&#10;                break;&#10;            }&#10;            prev = prev-&amp;gt;next;&#10;            curr = curr-&amp;gt;next;&#10;        }&#10;        return dummy.next;&#10;    }&#10;    ListNode* reverseList(ListNode* head, int length) {&#10;        ListNode* prev = NULL;&#10;        ListNode* curr = head;&#10;        ListNode* tmp = NULL;&#10;        for (int i = 0; i &amp;lt; length; i++) {&#10;            ListNode* next = curr-&amp;gt;next;&#10;            curr-&amp;gt;next = prev;&#10;            prev = curr;&#10;            curr = next;&#10;            if (i == 0) {&#10;                tmp = prev;    &#10;            }&#10;        }&#10;        tmp-&amp;gt;next = curr;&#10;        return prev;&#10;    }&#10;};&#10;" /></outline>
        <outline text="linked list cycle ii" >
          <outline text="描述" _note="找出有环链表的环开始的结点。" />
          <outline text="思路" _note="使用快慢指针，slow每次走一步，fast每次都两步，当slow == fast时，slow = head，然后slow和fast都走一步，相聚即为结点。&#10;                  +-----+&#10;                   |        |&#10;--------------+-----x&#10;      a                b&#10;具体的证明是，假设slow和fast第一次相遇在x点，此时slow走了a+b，fast走了a+b+c+b，其中b+c=cycle。而(a+b)*2 = a+b+c+b，所以a和c相等。所以，把slow重置为head，然后slow和fast各走a步就相聚了。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param head: The first node of linked list.&#10;     * @return: The node where the cycle begins. &#10;     *           if there is no cycle, return null&#10;     */&#10;    ListNode *detectCycle(ListNode *head) {&#10;        ListNode* slow = head;&#10;        ListNode* fast = head;&#10;        while (fast != NULL) {&#10;            slow = slow-&amp;gt;next;&#10;            fast = fast-&amp;gt;next;&#10;            if (fast != NULL)&#10;                fast = fast-&amp;gt;next;&#10;            if (slow == fast) {&#10;                break;&#10;            }&#10;        }&#10;        if (fast == NULL)&#10;            return NULL;&#10;            &#10;        slow = head;&#10;        while (slow != fast) {&#10;            slow = slow-&amp;gt;next;&#10;            fast = fast-&amp;gt;next;&#10;        }&#10;        return slow;&#10;    }&#10;};&#10;&#10;&#10;" /></outline>
      </outline>
      <outline text="Binary Tree" >
        <outline text="maximum depth of binary tree" >
          <outline text="描述" _note="求树的最大深度。" />
          <outline text="思路" _note="树的最大深度 = max(左子树的最大深度, 右子树的最大深度) + 1" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: An integer&#10;     */&#10;    int maxDepth(TreeNode *root) {&#10;        if (root == NULL)&#10;            return 0;&#10;        return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="insert node in a binary search tree" >
          <outline text="描述" _note="把一个结点插入到一颗BST中。" />
          <outline text="思路" _note="如果node-&amp;gt;left == NULL &amp;amp;&amp;amp; value &amp;lt; node-&amp;gt;val，则node-&amp;gt;left  = new TreeNode(value)；如果node-&amp;gt;right == NULL &amp;amp;&amp;amp; value &amp;gt; node-&amp;gt;val，则node-&amp;gt;right = new TreeNode(value)。否则递归寻找可以插入的结插入。 " />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of the binary search tree.&#10;     * @param node: insert this node into the binary search tree&#10;     * @return: The root of the new binary search tree.&#10;     */&#10;    TreeNode* insertNode(TreeNode* root, TreeNode* node) {&#10;        if (root == NULL)&#10;            return node;&#10;        &#10;        if (node-&amp;gt;val &amp;lt; root-&amp;gt;val) {&#10;            if (root-&amp;gt;left == NULL)&#10;                root-&amp;gt;left = node;&#10;            else&#10;                insertNode(root-&amp;gt;left, node);&#10;        }&#10;        else if (node-&amp;gt;val &amp;gt; root-&amp;gt;val) {&#10;            if (root-&amp;gt;right == NULL)&#10;                root-&amp;gt;right = node;&#10;            else&#10;                insertNode(root-&amp;gt;right, node);&#10;        }&#10;        return root;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree preorder traversal" >
          <outline text="描述" _note="先序遍历二叉树。" />
          <outline text="思路" _note="先序即先访问根，先输出根，再递归遍历左子树和右子树。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: Preorder in vector which contains node values.&#10;     */&#10;    vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode *root) {&#10;        static vector&amp;lt;int&amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        result.push_back(root-&amp;gt;val);&#10;        preorderTraversal(root-&amp;gt;left);&#10;        preorderTraversal(root-&amp;gt;right);&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="validate binary search tree" >
          <outline text="描述" _note="判断一棵树是否是BST。" />
          <outline text="思路" _note="BST是左子树的值都小于根的值，右子树的值都大于根的值。不能通过遍历树，判断左结点小于当前结点且右结点大于当前结点的方法判断，因为左结点小于当前结点不代表左结点的孩子都小于当前结点。具体可行的做法是，给每一个结点贴上2个值min和max，其孩子要保证在min和max之间。注意，初始的min和max用long类型，如果用int，结点值可能是INT_MAX。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: True if the binary tree is BST, or false&#10;     */&#10;    bool isValidBST(TreeNode *root) {&#10;        return _isValidBST(root, LONG_MIN, LONG_MAX);        &#10;    }&#10;    bool _isValidBST(TreeNode* root, long min, long max) {&#10;        if (root == NULL)&#10;            return true;&#10;            &#10;        if (min &amp;lt; root-&amp;gt;val &amp;amp;&amp;amp; root-&amp;gt;val &amp;lt; max)&#10;            return _isValidBST(root-&amp;gt;left, min, root-&amp;gt;val)&#10;                &amp;amp;&amp;amp; _isValidBST(root-&amp;gt;right, root-&amp;gt;val, max);&#10;        return false;&#10;    }&#10;};&#10;" /></outline>
        <outline text="balanced binary tree" >
          <outline text="描述" _note="判断一颗二叉树是否平衡。" />
          <outline text="思路" _note="平衡即任意一点的左子树高度和右子树的高度差小于等于1。要在每个结点上都测试，是否是平衡的，如果不是，则返回-1，上层结点就无需再判定了，直接返回false，否则则返回树的高度。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: True if this Binary tree is Balanced, or false.&#10;     */&#10;    bool isBalanced(TreeNode *root) {&#10;        return _isBalanced(root) == -1 ? false : true;&#10;    }&#10;    int _isBalanced(TreeNode* root) {&#10;        if (root == NULL)&#10;            return 0;&#10;            &#10;        int heightLeft = _isBalanced(root-&amp;gt;left);&#10;        int heightRight = _isBalanced(root-&amp;gt;right);&#10;        return heightLeft != -1&#10;            &amp;amp;&amp;amp; heightRight != -1&#10;            &amp;amp;&amp;amp; abs(heightLeft - heightRight) &amp;lt;= 1&#10;            ? max(heightLeft, heightRight) + 1&#10;            : -1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="construct binary tree from preorder and inorder traversal" >
          <outline text="描述" _note="从前序和中序遍历序列构造一棵二叉树。" />
          <outline text="思路" _note="前序的第一个元素是根，然后在中序中找到该结点，左侧是左子树，右侧是右子树。至此，就构造好了根，再递归的构造左子树和右子树，并把node-&amp;gt;left和node-&amp;gt;right指向构造好的左右子树。" />
          <outline text="代码一" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10;&#10;class Solution {&#10;    /**&#10;     *@param preorder : A list of integers that preorder traversal of a tree&#10;     *@param inorder : A list of integers that inorder traversal of a tree&#10;     *@return : Root of a tree&#10;     */&#10;public:&#10;    TreeNode *buildTree(vector&amp;lt;int&amp;gt; &amp;amp;preorder, vector&amp;lt;int&amp;gt; &amp;amp;inorder) {&#10;        int i = 0;&#10;        return _buildTree(preorder, i, inorder, 0, inorder.size() - 1);&#10;    }&#10;    TreeNode* _buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, int&amp;amp; i, vector&amp;lt;int&amp;gt;&amp;amp; inorder, int left, int right) {&#10;        if (left &amp;gt; right) {&#10;            i--;&#10;            return NULL;&#10;        }&#10;        if (i &amp;gt;= preorder.size())&#10;            return NULL;&#10;            &#10;        int value = preorder[i];&#10;        TreeNode* root = new TreeNode(value);&#10;        int index = find(inorder.begin(), inorder.end(), value) - inorder.begin();&#10;        root-&amp;gt;left = _buildTree(&#10;            preorder,&#10;            ++i,&#10;            inorder,&#10;            left,&#10;            index - 1&#10;        );&#10;        root-&amp;gt;right = _buildTree(&#10;            preorder,&#10;            ++i,&#10;            inorder,&#10;            index + 1,&#10;            right&#10;        );&#10;        return root;&#10;    }&#10;};&#10;" />
          <outline text="代码二" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10;&#10;class Solution {&#10;    /**&#10;     *@param preorder : A list of integers that preorder traversal of a tree&#10;     *@param inorder : A list of integers that inorder traversal of a tree&#10;     *@return : Root of a tree&#10;     */&#10;public:&#10;    TreeNode *buildTree(vector&amp;lt;int&amp;gt; &amp;amp;preorder, vector&amp;lt;int&amp;gt; &amp;amp;inorder) {&#10;        return _buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);&#10;    }&#10;    TreeNode* _buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, int preBegin, int preEnd, vector&amp;lt;int&amp;gt;&amp;amp; inorder, int inBegin, int inEnd) {&#10;        if (preBegin &amp;gt; preEnd)&#10;            return NULL;&#10;            &#10;        int value = preorder[preBegin];&#10;        TreeNode* root = new TreeNode(value);&#10;        int index = find(inorder.begin(), inorder.end(), value) - inorder.begin();&#10;        root-&amp;gt;left = _buildTree(preorder, preBegin + 1, preBegin + index - inBegin, inorder, inBegin, index - 1);&#10;        root-&amp;gt;right = _buildTree(preorder, preBegin + index - inBegin + 1, preEnd, inorder, index + 1, inEnd);&#10;        return root;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree level order traversal" >
          <outline text="描述" _note="按层次遍历二叉树。" />
          <outline text="思路" _note="使用BFS的方式，用一个队列模拟。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10; &#10;class Solution {&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: Level order a list of lists of integer&#10;     */&#10;public:&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode *root) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        queue&amp;lt;TreeNode*&amp;gt; cache;&#10;        cache.push(root);&#10;        while (!cache.empty()) {&#10;            vector&amp;lt;int&amp;gt; row;&#10;            int count = cache.size();&#10;            for (int i = 0; i &amp;lt; count; i++) {&#10;                TreeNode* node = cache.front();&#10;                cache.pop();&#10;                row.push_back(node-&amp;gt;val);&#10;                &#10;                if (node-&amp;gt;left != NULL)&#10;                    cache.push(node-&amp;gt;left);&#10;                if (node-&amp;gt;right != NULL)&#10;                    cache.push(node-&amp;gt;right);&#10;                &#10;            }&#10;            result.push_back(row);&#10;            &#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="search range in binary search tree" >
          <outline text="描述" _note="给定一个数值范围，把BST中符合范围的数找出。" />
          <outline text="思路" _note="判断当前结点是否符合，如果符合则保存下值，继续递归判断左右子树。如果不符合，则判断是去左子树递归还是右子树。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of the binary search tree.&#10;     * @param k1 and k2: range k1 to k2.&#10;     * @return: Return all keys that k1&amp;lt;=key&amp;lt;=k2 in ascending order.&#10;     */&#10;    vector&amp;lt;int&amp;gt; searchRange(TreeNode* root, int k1, int k2) {&#10;        vector&amp;lt;int&amp;gt; result = _searchRange(root, k1, k2);&#10;        sort(result.begin(), result.end());&#10;        return result;&#10;    }&#10;    vector&amp;lt;int&amp;gt; _searchRange(TreeNode* root, int k1, int k2) {&#10;        static vector&amp;lt;int&amp;gt; result;&#10;        &#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        if (k1 &amp;lt;= root-&amp;gt;val &amp;amp;&amp;amp; root-&amp;gt;val &amp;lt;= k2) {&#10;            result.push_back(root-&amp;gt;val);&#10;            searchRange(root-&amp;gt;left, k1, k2);&#10;            searchRange(root-&amp;gt;right, k1, k2);&#10;        }&#10;        else if (root-&amp;gt;val &amp;lt; k1)&#10;            searchRange(root-&amp;gt;right, k1, k2);&#10;        else if (root-&amp;gt;val &amp;gt; k2)&#10;            searchRange(root-&amp;gt;left, k1, k2);&#10;        &#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree serialization" >
          <outline text="描述" _note="序列化和反序列化一棵二叉树。" />
          <outline text="思路" _note="使用先序遍历来序列和反序列化。" />
          <outline text="代码一" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * This method will be invoked first, you should design your own algorithm &#10;     * to serialize a binary tree which denote by a root node to a string which&#10;     * can be easily deserialized by your own &quot;deserialize&quot; method later.&#10;     */&#10;    string serialize(TreeNode *root) {&#10;        static string result;&#10;            &#10;        if (root == NULL) {&#10;            result += &quot;#,&quot;;&#10;            return result;&#10;        }&#10;        &#10;        stringstream tmp;&#10;        tmp &amp;lt;&amp;lt; root-&amp;gt;val;&#10;        result += tmp.str();&#10;        result += ',';&#10;        serialize(root-&amp;gt;left);&#10;        serialize(root-&amp;gt;right);&#10;        &#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * This method will be invoked second, the argument data is what exactly&#10;     * you serialized at method &quot;serialize&quot;, that means the data is not given by&#10;     * system, it's given by your own serialize method. So the format of data is&#10;     * designed by yourself, and deserialize it here as you serialize it in &#10;     * &quot;serialize&quot; method.&#10;     */&#10;    TreeNode *deserialize(string data) {&#10;        vector&amp;lt;string&amp;gt; strs = split(data, ',');&#10;        return _deserialize(strs);&#10;    }&#10;    TreeNode* _deserialize(vector&amp;lt;string&amp;gt;&amp;amp; strs) {&#10;        static int index = 0;&#10;        if (index &amp;gt;= strs.size() || strs[index] == &quot;#&quot;) {&#10;            index++;&#10;            return NULL;&#10;        }&#10;            &#10;        TreeNode* root = new TreeNode(atoi(strs[index++].c_str()));&#10;        root-&amp;gt;left = _deserialize(strs);&#10;        root-&amp;gt;right = _deserialize(strs);&#10;        return root;&#10;    }&#10;    vector&amp;lt;string&amp;gt; split(string s, char splitter) {&#10;        const char* base = s.c_str();&#10;        const char *p = base;&#10;        const char *q = base;&#10;        vector&amp;lt;string&amp;gt; v;&#10;&#10;        while (*p != '\0') {&#10;            if (p == q) {&#10;                while (*q != splitter &amp;amp;&amp;amp; *q != '\0')&#10;                    q++;&#10;            }&#10;            v.push_back(s.substr(p - base, q - p));&#10;            q++;&#10;            p = q;&#10;        }&#10;        return v;&#10;    }&#10;};&#10;" />
          <outline text="代码二" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * This method will be invoked first, you should design your own algorithm &#10;     * to serialize a binary tree which denote by a root node to a string which&#10;     * can be easily deserialized by your own &quot;deserialize&quot; method later.&#10;     */&#10;    string serialize(TreeNode *root) {&#10;        static string result;&#10;            &#10;        if (root == NULL) {&#10;            result += &quot;#,&quot;;&#10;            return result;&#10;        }&#10;        &#10;        stringstream tmp;&#10;        tmp &amp;lt;&amp;lt; root-&amp;gt;val;&#10;        result += tmp.str();&#10;        result += ',';&#10;        serialize(root-&amp;gt;left);&#10;        serialize(root-&amp;gt;right);&#10;        &#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * This method will be invoked second, the argument data is what exactly&#10;     * you serialized at method &quot;serialize&quot;, that means the data is not given by&#10;     * system, it's given by your own serialize method. So the format of data is&#10;     * designed by yourself, and deserialize it here as you serialize it in &#10;     * &quot;serialize&quot; method.&#10;     */&#10;    TreeNode *deserialize(string data) {&#10;        vector&amp;lt;string&amp;gt; strs = split(data, ',');&#10;        return _deserialize(strs);&#10;    }&#10;    TreeNode* _deserialize(vector&amp;lt;string&amp;gt;&amp;amp; strs) {&#10;        static int index = 0;&#10;        if (index &amp;gt;= strs.size() || strs[index] == &quot;#&quot;)&#10;            return NULL;&#10;            &#10;        TreeNode* root = new TreeNode(atoi(strs[index].c_str()));&#10;        index++;&#10;        root-&amp;gt;left = _deserialize(strs);&#10;        index++;&#10;        root-&amp;gt;right = _deserialize(strs);&#10;        return root;&#10;    }&#10;    vector&amp;lt;string&amp;gt; split(string s, char splitter) {&#10;        const char* base = s.c_str();&#10;        const char *p = base;&#10;        const char *q = base;&#10;        vector&amp;lt;string&amp;gt; v;&#10;&#10;        while (*p != '\0') {&#10;            if (p == q) {&#10;                while (*q != splitter &amp;amp;&amp;amp; *q != '\0')&#10;                    q++;&#10;            }&#10;            v.push_back(s.substr(p - base, q - p));&#10;            q++;&#10;            p = q;&#10;        }&#10;        return v;&#10;    }&#10;};&#10;" /></outline>
        <outline text="minimum depth of binary tree" >
          <outline text="描述" _note="求树的根结点到最近叶子的层数。" />
          <outline text="思路" _note="根到最近的叶子的层数 = (左孩子根结点到最近叶子的层数，右孩子根节点到最近叶子的层数)+1。注意，如果某个根结点没有左孩子，则只能去右边寻找。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: An integer&#10;     */&#10;    int minDepth(TreeNode *root) {&#10;        if (root == NULL)&#10;            return 0;&#10;        int left = minDepth(root-&amp;gt;left);&#10;        int right = minDepth(root-&amp;gt;right);&#10;        if (left == 0)&#10;            return right + 1;&#10;        if (right == 0)&#10;            return left + 1;&#10;        return min(left, right) + 1;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree inorder traversal" >
          <outline text="描述" _note="中序遍历二叉树。" />
          <outline text="思路" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: Inorder in vector which contains node values.&#10;     */&#10;public:&#10;    vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode *root) {&#10;        static vector&amp;lt;int&amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        inorderTraversal(root-&amp;gt;left);&#10;        result.push_back(root-&amp;gt;val);&#10;        inorderTraversal(root-&amp;gt;right);&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree preorder traversal" >
          <outline text="描述" _note="先序遍历二叉树。" />
          <outline text="思路" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10;&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: Preorder in vector which contains node values.&#10;     */&#10;    vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode *root) {&#10;        static vector&amp;lt;int&amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        result.push_back(root-&amp;gt;val);&#10;        preorderTraversal(root-&amp;gt;left);&#10;        preorderTraversal(root-&amp;gt;right);&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="unique binary search trees" >
          <outline text="描述" _note="给定{1,2,...,n}个数值，求构建出的BST有几种。" />
          <outline text="思路" _note="假设BST的根是i，则左子树只能使用{1,2,...,i-1}构建，右子树只能使用{i+1,...,n}构建。所以可以使用动态规划求解，n&amp;lt;=1时，只有一种BST。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @paramn n: An integer&#10;     * @return: An integer&#10;     */&#10;    int numTrees(int n) {&#10;        vector&amp;lt;int&amp;gt; dp(n + 1, 1);// 0 ~ n&#10;        for (int i = 2; i &amp;lt;= n; i++) {&#10;            dp[i] = 0;&#10;            for (int j = 1; j &amp;lt;= i; j++) {&#10;                dp[i] += dp[j - 1] * dp[i - j];&#10;            }&#10;        }&#10;        return dp[n];&#10;    }&#10;};&#10;" /></outline>
        <outline text="construct binary tree from inorder and postorder traversal" >
          <outline text="描述" _note="中序和后序序列构建二叉树。" />
          <outline text="思路" _note="后序序列的最后一个结点是根，即后序的模式是：左右根；而中序的模式是左根右。" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10;&#10;class Solution {&#10;    /**&#10;     *@param inorder : A list of integers that inorder traversal of a tree&#10;     *@param postorder : A list of integers that postorder traversal of a tree&#10;     *@return : Root of a tree&#10;     */&#10;public:&#10;    TreeNode *buildTree(vector&amp;lt;int&amp;gt; &amp;amp;inorder, vector&amp;lt;int&amp;gt; &amp;amp;postorder) {&#10;        int i = postorder.size() - 1;&#10;        return _buildTree(inorder, 0, inorder.size() - 1, postorder, i);&#10;    }&#10;    &#10;    TreeNode* _buildTree(vector&amp;lt;int&amp;gt; &amp;amp;inorder, int inBegin, int inEnd, vector&amp;lt;int&amp;gt; &amp;amp;postorder, int&amp;amp; i) {&#10;        if (i &amp;lt; 0)&#10;            return NULL;&#10;        if (inBegin &amp;gt; inEnd) {&#10;            i++;&#10;            return NULL;&#10;        }&#10;            &#10;        int value = postorder[i];&#10;        int index = find(inorder.begin(), inorder.end(), value) - inorder.begin();&#10;        &#10;        TreeNode* root = new TreeNode(value);&#10;        root-&amp;gt;right = _buildTree(inorder, index + 1, inEnd, postorder, --i);&#10;        root-&amp;gt;left = _buildTree(inorder, inBegin, index - 1, postorder, --i);&#10;        return root;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree zigzag level order traversal" >
          <outline text="描述" _note="自顶向下打印树，奇数层正序打印，偶数层逆序打印。" />
          <outline text="思路" _note="可以使用queue，然后BFS，在偶数层reverse一下。还有更好的方法，即使用2个stack，不使用queue。" />
          <outline text="代码一（需要逆序）" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10;&#10;class Solution {&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: A list of lists of integer include &#10;     *          the zigzag level order traversal of its nodes' values &#10;     */&#10;public:&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode *root) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        queue&amp;lt;TreeNode*&amp;gt; cache;&#10;        cache.push(root);&#10;        bool positive = true;&#10;        while (!cache.empty()) {&#10;            vector&amp;lt;int&amp;gt; row;&#10;            int count = cache.size();&#10;            for (int i = 0; i &amp;lt; count; i++) {&#10;                TreeNode* node = cache.front();&#10;                cache.pop();&#10;                row.push_back(node-&amp;gt;val);&#10;                &#10;                if (node-&amp;gt;left != NULL)&#10;                    cache.push(node-&amp;gt;left);&#10;                if (node-&amp;gt;right != NULL)&#10;                    cache.push(node-&amp;gt;right);&#10;            }&#10;            if (!positive)&#10;                reverse(row.begin(), row.end());&#10;            result.push_back(row);&#10;            positive = !positive;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" />
          <outline text="代码二（无需逆序）" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10;&#10;class Solution {&#10;    /**&#10;     * @param root: The root of binary tree.&#10;     * @return: A list of lists of integer include &#10;     *          the zigzag level order traversal of its nodes' values &#10;     */&#10;public:&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode *root) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        stack&amp;lt;TreeNode*&amp;gt; cache1;&#10;        stack&amp;lt;TreeNode*&amp;gt; cache2;&#10;        cache1.push(root);&#10;        bool positive = true;&#10;        while (!cache1.empty()) {&#10;            vector&amp;lt;int&amp;gt; row;&#10;            while (!cache1.empty()) {&#10;                TreeNode* node = cache1.top();&#10;                cache1.pop();&#10;                row.push_back(node-&amp;gt;val);&#10;                if (positive) {&#10;                    if (node-&amp;gt;left != NULL)&#10;                        cache2.push(node-&amp;gt;left);&#10;                    if (node-&amp;gt;right != NULL)&#10;                        cache2.push(node-&amp;gt;right);&#10;                }&#10;                else {&#10;                    if (node-&amp;gt;right != NULL)&#10;                        cache2.push(node-&amp;gt;right);&#10;                    if (node-&amp;gt;left != NULL)&#10;                        cache2.push(node-&amp;gt;left);&#10;                }&#10;            }&#10;            result.push_back(row);&#10;            positive = !positive;&#10;            &#10;            stack&amp;lt;TreeNode*&amp;gt; tmp = cache2;&#10;            cache2 = cache1;&#10;            cache1 = tmp;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="binary tree level order traversal ii" >
          <outline text="描述" _note="按层逆序打印树，即自底向上打印。" />
          <outline text="思路" _note="使用queue进行BFS，最后reverse结果。（有没有不reverse的更好方法呢？）" />
          <outline text="代码" _note="/**&#10; * Definition of TreeNode:&#10; * class TreeNode {&#10; * public:&#10; *     int val;&#10; *     TreeNode *left, *right;&#10; *     TreeNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;left = this-&amp;gt;right = NULL;&#10; *     }&#10; * }&#10; */&#10; &#10; &#10;class Solution {&#10;    /**&#10;     * @param root : The root of binary tree.&#10;     * @return : buttom-up level order a list of lists of integer&#10;     */&#10;public:&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrderBottom(TreeNode *root) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        if (root == NULL)&#10;            return result;&#10;            &#10;        queue&amp;lt;TreeNode*&amp;gt; cache;&#10;        cache.push(root);&#10;        while(!cache.empty()) {&#10;            int count = cache.size();&#10;            vector&amp;lt;int&amp;gt; row;&#10;            for (int i = 0; i &amp;lt; count; i++) {&#10;                TreeNode* node = cache.front();&#10;                cache.pop();&#10;                row.push_back(node-&amp;gt;val);&#10;                &#10;                if (node-&amp;gt;left != NULL)&#10;                    cache.push(node-&amp;gt;left);&#10;                if (node-&amp;gt;right != NULL)&#10;                    cache.push(node-&amp;gt;right);                &#10;            }&#10;            result.push_back(row);&#10;        }&#10;        reverse(result.begin(), result.end());&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Search &amp;amp; Recursion" >
        <outline text="combinations" >
          <outline text="描述" _note="求所有的组合C(n,k)，从1~n中取k个数。" />
          <outline text="思路" _note="dfs搜索，根结点可以是1~n，对于第一层的某一个结点再产生第二层的结点，以此类推。当层数为k时，即停止并返回到上一层，对于上一层pop出刚才在下层添加的元素，继续选择上层中可选的下一个结点。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param n: Given the range of numbers&#10;     * @param k: Given the numbers of combinations&#10;     * @return: All the combinations of k numbers out of 1..n&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; combine(int n, int k) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        dfs(1, n, k, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int curr, int n, int k, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        if (item.size() == k) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;        &#10;        for (int i = curr; i &amp;lt;= n; i++) {&#10;            item.push_back(i);&#10;            dfs(i + 1, n, k, item, result);&#10;            item.pop_back();&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="combination sum" >
          <outline text="描述" _note="对定一堆数，从中选若干个使得和为给定的sum，每个数可以选择多次。" />
          <outline text="思路" _note="先对给定的数进行排序并去重复。假设某层的结点为x，则x的下层的结点值为大于等于x，此处不可产生小于&#10;x的值，因为会造成重复。之前先对数进行排序并去重就是为了这一点。策略还是push当前的结点，然后递归其子结点，完了以后在pop当前结点。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param candidates: A list of integers&#10;     * @param target:An integer&#10;     * @return: A list of lists of integers&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; combinationSum(vector&amp;lt;int&amp;gt; candidates, int target) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        sort(candidates.begin(), candidates.end());&#10;        candidates.erase(unique(candidates.begin(), candidates.end()), candidates.end());&#10;        int sumOfItem = 0;&#10;        &#10;        dfs(candidates, target, 0, sumOfItem, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int curr, int sumOfItem, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        if (sumOfItem == target) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;        if (sumOfItem &amp;gt; target)&#10;            return;&#10;            &#10;        for (int i = curr; i &amp;lt; candidates.size(); i++) {&#10;            item.push_back(candidates[i]);&#10;            sumOfItem += candidates[i];&#10;            dfs(candidates, target, i, sumOfItem, item, result);&#10;            sumOfItem -= candidates[i];&#10;            item.pop_back();&#10;        }        &#10;    }&#10;};&#10;" /></outline>
        <outline text="topological sorting" >
          <outline text="描述" _note="给定一个有向图，输出topological sorting序列，也就是说按照箭头的方向输出，如果没法区分前后次序，则随意输出次序。比如a-&amp;gt;b-&amp;gt;c, a-&amp;gt;d-&amp;gt;c，可以输出a, b, d, c或a, d, b, c。" />
          <outline text="思路" _note="需要先找到起点，一个图中可能有多个起点，比如a-&amp;gt;b-&amp;gt;c，d-&amp;gt;c，这里a和d都可以作为起点。做到这点的方法是，一次遍历图中的每个结点，记录下每个结点对应neighbors结点的次数visited[node]，即有几个箭头指向这个结点，也就是说还可以访问node结点visited[node]次。然后在对每一个起点进行dfs。" />
          <outline text="代码" _note="/**&#10; * Definition for Directed graph.&#10; * struct DirectedGraphNode {&#10; *     int label;&#10; *     vector&amp;lt;DirectedGraphNode *&amp;gt; neighbors;&#10; *     DirectedGraphNode(int x) : label(x) {};&#10; * };&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param graph: A list of Directed graph node&#10;     * @return: Any topological order for the given graph.&#10;     */&#10;    vector&amp;lt;DirectedGraphNode*&amp;gt; topSort(vector&amp;lt;DirectedGraphNode*&amp;gt; graph) {&#10;        map&amp;lt;DirectedGraphNode*, int&amp;gt; visited;&#10;        for (int i = 0; i &amp;lt; graph.size(); i++) {&#10;            for (int j = 0; j &amp;lt; graph[i]-&amp;gt;neighbors.size(); j++) {&#10;                if (visited.find(graph[i]-&amp;gt;neighbors[j]) == visited.end())&#10;                    visited[graph[i]-&amp;gt;neighbors[j]] = 1;&#10;                else&#10;                    visited[graph[i]-&amp;gt;neighbors[j]] += 1;&#10;            }&#10;        }        &#10;        &#10;        vector&amp;lt;DirectedGraphNode*&amp;gt; result;&#10;        for (int i = 0; i &amp;lt; graph.size(); i++) {&#10;            if (visited.find(graph[i]) == visited.end()) {&#10;                visited[graph[i]] = 0;&#10;                dfs(graph, graph[i], visited, result);        &#10;            }&#10;        }&#10;        return result;&#10;    }&#10;    &#10;    void dfs(vector&amp;lt;DirectedGraphNode*&amp;gt;&amp;amp; graph, DirectedGraphNode* node, map&amp;lt;DirectedGraphNode*, int&amp;gt;&amp;amp; visited, vector&amp;lt;DirectedGraphNode*&amp;gt;&amp;amp; result) {&#10;        visited[node]--;&#10;        &#10;        result.push_back(node);&#10;        for (int i = 0; i &amp;lt; node-&amp;gt;neighbors.size(); i++) {&#10;            visited[node-&amp;gt;neighbors[i]]--;&#10;            if (visited[node-&amp;gt;neighbors[i]] == 0)&#10;                dfs(graph, node-&amp;gt;neighbors[i], visited, result);&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="word ladder" >
          <outline text="描述" _note="start = &quot;hit&quot;, end = &quot;cog&quot;, dict = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]。计算从start变成end最少需要几次，每次变化只能改变一个字母且变化后的词在dict中出现。对于这个例子，&quot;hit&quot; -&amp;gt; &quot;hot&quot; -&amp;gt; &quot;dot&quot; -&amp;gt; &quot;dog&quot; -&amp;gt; &quot;cog&quot;，一共是5次。" />
          <outline text="思路" _note="一看到最少、最短，就要立马想到bfs。这里是从start开始，使用genStrs产生可以变化的下一层结点，然后再对每个结点产生下层结点，只能某层的某结点等于end为止。需要注意，在产生了某个结点后，要从dict中删除掉他，要不然某个结点（比如很下层的）可能还会产生这个结点，就不是最长的了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;      * @param start, a string&#10;      * @param end, a string&#10;      * @param dict, a set of string&#10;      * @return an integer&#10;      */&#10;    int ladderLength(string start, string end, unordered_set&amp;lt;string&amp;gt; &amp;amp;dict) {&#10;        queue&amp;lt;string&amp;gt; cache;&#10;        cache.push(start);&#10;        int distance = 1;&#10;        &#10;        while (!cache.empty()) {&#10;            int count = cache.size();&#10;            for (int i = 0; i &amp;lt; count; i++) {&#10;                string str = cache.front();&#10;                cache.pop();&#10;                if (str == end)&#10;                    return distance;&#10;                    &#10;                vector&amp;lt;string&amp;gt; strs = genStrs(dict, str);&#10;                for (int i = 0; i &amp;lt; strs.size(); i++) {&#10;                    cache.push(strs[i]);&#10;                    dict.erase(strs[i]);&#10;                }&#10;            }&#10;                &#10;            distance++;&#10;        }&#10;        return 0;&#10;    }&#10;    &#10;    vector&amp;lt;string&amp;gt; genStrs(unordered_set&amp;lt;string&amp;gt;&amp;amp; dict, string&amp;amp; str) {&#10;        vector&amp;lt;string&amp;gt; strs;&#10;        for (int i = 0; i &amp;lt; str.size(); i++) {&#10;            for (char ch = 'a'; ch &amp;lt;= 'z'; ch++) {&#10;                string s = str;&#10;                s[i] = ch;&#10;                if (s != str &amp;amp;&amp;amp; dict.find(s) != dict.end())&#10;                    strs.push_back(s);&#10;            }&#10;        }&#10;        return strs;&#10;    }&#10;};&#10;" /></outline>
        <outline text="n queens" >
          <outline text="描述" _note="在nxn的棋盘上放置n个棋子，使得任意两个都不在同一行、同一列、同一斜线。" />
          <outline text="思路" _note="先放第一个棋子，然后再基于其放第二个，再放第三个...。重新改变第一个棋子的位置，再放一遍...。所以需要dfs。关键是如何基于以前的放置，来放下一个，使得满足要求。这里需要使用state数组，state[i]的值表示第i行放置棋子的位置。每放一个棋子，就改变state[i]。在放下一个（其实就是下一行，放置的顺序是从0行开始，一行一行的放）棋子的时候，假设放到第i行，需要判断从第0列开始判断，是不是满足要求，判断方法是代码中的isValid。因为是按行放的棋子，所以这里只需要一次遍历state就可以找一个合适的列值。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * Get all distinct N-Queen solutions&#10;     * @param n: The number of queens&#10;     * @return: All distinct solutions&#10;     * For example, A string '...Q' shows a queen on forth position&#10;     */&#10;    vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; solveNQueens(int n) {&#10;        vector&amp;lt;int&amp;gt; state(n, 0);&#10;        vector&amp;lt;string&amp;gt; item;&#10;        vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; result;&#10;        &#10;        dfs(0, state, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int rowIndex,  vector&amp;lt;int&amp;gt;&amp;amp; state, vector&amp;lt;string&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt;&amp;amp; result) {&#10;        int n = state.size();&#10;        if (item.size() == n) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;        &#10;        for (int colIndex = 0; colIndex &amp;lt; state.size(); colIndex++) {&#10;            if (isValid(state, rowIndex, colIndex)) {&#10;                string row(n, '.');&#10;                row[colIndex] = 'Q';&#10;                state[rowIndex] = colIndex;&#10;                item.push_back(row);&#10;                dfs(rowIndex + 1, state, item, result);&#10;                item.pop_back();&#10;            }&#10;        }&#10;    }&#10;    &#10;    bool isValid(vector&amp;lt;int&amp;gt;&amp;amp; state, int rowIndex, int colIndex) {&#10;        for (int i = 0; i &amp;lt; rowIndex; i++) {&#10;            if (state[i] == colIndex || abs(i - rowIndex) == abs(state[i] - colIndex))&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;};&#10;" /></outline>
        <outline text="subsets ii" >
          <outline text="描述" _note="有一个集合，数字可能重复，求其所有的子集。" />
          <outline text="思路" _note="看到重复，自然就想到了先排序，这样可以防止在后面的过程重复产生一样的子集。然后通过这个判断i == curr ||  s[i] != s[i - 1]来保证产生不重复的子集，注意这里的i == curr，对于1,1,2这个的子集，肯定是会有1,1的，即第一层产生了1以后，下一层还是1，尽管和上一层的1相等，但是我们还是不能跳过他。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param S: A set of numbers.&#10;     * @return: A list of lists. All valid subsets.&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {&#10;        vector&amp;lt;int&amp;gt; s = S;&#10;        sort(s.begin(), s.end());&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        result.push_back(item);&#10;        &#10;        dfs(0, s, item, result);&#10;        return result;        &#10;    }&#10;    &#10;    void dfs(int curr, vector&amp;lt;int&amp;gt;&amp;amp; s, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        for (int i = curr; i &amp;lt; s.size(); i++) {&#10;            if (i == curr ||  s[i] != s[i - 1]) {&#10;                item.push_back(s[i]);&#10;                result.push_back(item);&#10;                dfs(i + 1, s, item, result);&#10;                item.pop_back();&#10;            }&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="subsets" >
          <outline text="描述" _note="给定一个包含不重复数字的集合，产生所有的子集。" />
          <outline text="思路" _note="因为每一个数字都不相同，所有即可对每个数字dfs。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param S: A set of numbers.&#10;     * @return: A list of lists. All valid subsets.&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        result.push_back(item);&#10;        &#10;        dfs(0, nums, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int curr, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        for (int i = curr; i &amp;lt; nums.size(); i++) {&#10;            item.push_back(nums[i]);&#10;            result.push_back(item);&#10;            dfs(i + 1, nums, item, result);&#10;            item.pop_back();&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="permutations ii" >
          <outline text="描述" _note="求包含重复元素的所有排列。" />
          <outline text="思路" _note="看到重复，首先要对输入进行排序。然后对每一个元素dfs，这里需要使用swap的方式，如果我们对第i个元素dfs，直接dfs是不好弄的，所以把第i个元素换到最前面，如果是第2层，就换到第2个元素，再对后面的排序，再dfs。因为最开始的排序并不能保证一直是有序的，swap会改变顺序。这些操作会代表输入，所以每次都要先backup一下，dfs完了再恢复。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers.&#10;     * @return: A list of unique permutations.&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permuteUnique(vector&amp;lt;int&amp;gt; nums) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        sort(nums.begin(), nums.end());&#10;        &#10;        if (nums.size() == 0)&#10;            return result;&#10;            &#10;        dfs(0, nums, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int curr, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        if (item.size() == nums.size()) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;            &#10;        for (int i = curr; i &amp;lt; nums.size(); i++) {&#10;            if (i == curr || nums[i] != nums[i - 1]) {&#10;                vector&amp;lt;int&amp;gt; backup = nums;&#10;                swap(nums, i, curr);&#10;                sort(nums.begin() + curr + 1, nums.end());&#10;                item.push_back(nums[curr]);&#10;                dfs(curr + 1, nums, item, result);//important&#10;                item.pop_back();&#10;                nums = backup;//important&#10;            }&#10;        }&#10;    }&#10;    &#10;    void swap(vector&amp;lt;int&amp;gt;&amp;amp; v, int i, int j) {&#10;        int tmp = v[i];&#10;        v[i] = v[j];&#10;        v[j] = tmp;&#10;    }&#10;};&#10;" /></outline>
        <outline text="permutations" >
          <outline text="描述" _note="给定不重复的集合，求所有可能的排列。" />
          <outline text="思路" _note="因为集合的数字各不相同，所以可以对每个数dfs。如果对第k层的第i个数dfs，则先swap第i个元素到第k个位置，dfs完了再swap成原来的样子。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers.&#10;     * @return: A list of permutations.&#10;     */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permute(vector&amp;lt;int&amp;gt; nums) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        &#10;        if (nums.size() == 0)&#10;            return result;&#10;            &#10;        dfs(0, nums, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int curr, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        if (item.size() == nums.size()) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;            &#10;        for (int i = curr; i &amp;lt; nums.size(); i++) {&#10;            swap(nums, i, curr);&#10;            item.push_back(nums[curr]);&#10;            dfs(curr + 1, nums, item, result);//important&#10;            item.pop_back();&#10;            swap(nums, i, curr);//important&#10;        }&#10;    }&#10;    &#10;    void swap(vector&amp;lt;int&amp;gt;&amp;amp; v, int i, int j) {&#10;        int tmp = v[i];&#10;        v[i] = v[j];&#10;        v[j] = tmp;&#10;    }&#10;};&#10;" /></outline>
        <outline text="word ladder ii" >
          <outline text="描述" _note="同word ladder，将start转换成end，只能使用dict的词进行转换，且每次转换只能改变一个字母。求最少转换次数下的所有可能的转换。" />
          <outline text="思路" _note="直接用bfs只能求出最短的路径，但是不能求出所有的路径。原来的策略是，每次转换到一个新的词，就把这个词从dict中删掉，这里是不可行的，因为这个词可能在另一个转换路径上出现。但是可以肯定，这个词只能在这一层使用，在下一层使用肯定会使转换次数变多。所以，在一层bfs完成后，统一对所有使用的词进行删除。还需要一个found变量记录，一旦找到start == end，则就不再继续进行下一层。还有一个问题是，要将所有的路径存储下来，存储使用unordered_map&amp;lt;string, unordered_set&amp;lt;string&amp;gt; &amp;gt; paths; key存储下一个结点，value存储可以到达key的所有结点。最后对paths进行dfs，可以还原出所有路径到vector。为了方便dfs，之前的bfs从end找start，而不是从start找end。&#10;" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;      * @param start, a string&#10;      * @param end, a string&#10;      * @param dict, a set of string&#10;      * @return a list of lists of string&#10;      */&#10;    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; findLadders(string start, string end, unordered_set&amp;lt;string&amp;gt; &amp;amp;dict) {&#10;        unordered_map&amp;lt;string, unordered_set&amp;lt;string&amp;gt; &amp;gt; paths;&#10;        queue&amp;lt;string&amp;gt; cache;&#10;        bool found = false;&#10;        cache.push(end);&#10;&#10;        while (!cache.empty()) {&#10;            vector&amp;lt;string&amp;gt; tmp;&#10;            while (!cache.empty()) {&#10;                string str = cache.front();&#10;                cache.pop();&#10;                &#10;                if (str == start)&#10;                    found = true;&#10;                tmp.push_back(str);&#10;            }&#10;            &#10;            if (found)&#10;                break;&#10;            else {&#10;                for (int i = 0; i &amp;lt; tmp.size(); i++) {&#10;                    dict.erase(tmp[i]);&#10;                }&#10;                for (int i = 0; i &amp;lt; tmp.size(); i++) {&#10;                    string str = tmp[i];&#10;                    vector&amp;lt;string&amp;gt; strs = genStrs(dict, str);&#10;                    for (int j = 0; j &amp;lt; strs.size(); j++) {&#10;                        paths[strs[j]].insert(str);&#10;                        cache.push(strs[j]);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;string&amp;gt; item;&#10;        item.push_back(start);&#10;        dfs(item, start, end, paths, result);&#10;        return result;&#10;    }&#10;    &#10;    vector&amp;lt;string&amp;gt; genStrs(unordered_set&amp;lt;string&amp;gt;&amp;amp; dict, string&amp;amp; str) {&#10;        vector&amp;lt;string&amp;gt; strs;&#10;        for (int i = 0; i &amp;lt; str.size(); i++) {&#10;            for (char ch = 'a'; ch &amp;lt;= 'z'; ch++) {&#10;                string s = str;&#10;                s[i] = ch;&#10;                if (s != str &amp;amp;&amp;amp; dict.find(s) != dict.end())&#10;                    strs.push_back(s);&#10;            }&#10;        }&#10;        return strs;&#10;    }&#10;    &#10;    void dfs(vector&amp;lt;string&amp;gt;&amp;amp; item, string start, string end, unordered_map&amp;lt;string, unordered_set&amp;lt;string&amp;gt; &amp;gt;&amp;amp; paths, vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt;&amp;amp; result) {&#10;        if (start == end) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;            &#10;        for (unordered_set&amp;lt;string&amp;gt;::iterator i = paths[start].begin(); i != paths[start].end(); i++) {&#10;            item.push_back(*i);&#10;            dfs(item, *i, end, paths, result);&#10;            item.pop_back();&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="combination sum ii" >
          <outline text="描述" _note="求给定集合的所有可能的子集，使得子集的和等于给定值，给定集合的数字可能重复。" />
          <outline text="思路" _note="看到重复，首先要排序，然后对其dfs。使用i == curr || num[i] != num[i - 1]保证不会产生重复的子集。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;	/**&#10;	 * @param num: Given the candidate numbers&#10;	 * @param target: Given the target number&#10;	 * @return: All the combinations that sum to target&#10;	 */&#10;    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; combinationSum2(vector&amp;lt;int&amp;gt; num, int target) {&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; result;&#10;        vector&amp;lt;int&amp;gt; item;&#10;        int sumOfItem = 0;&#10;        sort(num.begin(), num.end());&#10;        dfs(0, num, target, sumOfItem, item, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int curr, vector&amp;lt;int&amp;gt;&amp;amp; num, int target, int sumOfItem, vector&amp;lt;int&amp;gt;&amp;amp; item, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; result) {&#10;        if (sumOfItem == target) {&#10;            result.push_back(item);&#10;            return;&#10;        }&#10;        if (sumOfItem &amp;gt; target)&#10;            return;&#10;            &#10;        for (int i = curr; i &amp;lt; num.size(); i++) {&#10;            if (i == curr || num[i] != num[i - 1]) {&#10;                sumOfItem += num[i];&#10;                item.push_back(num[i]);&#10;                dfs(i + 1, num, target, sumOfItem, item, result);&#10;                item.pop_back();&#10;                sumOfItem -= num[i];&#10;            }&#10;        }&#10;    }&#10;};&#10;" /></outline>
        <outline text="clone graph" >
          <outline text="描述" _note="深拷贝一个无向图。" />
          <outline text="思路" _note="使用一个map，把所有的结点拷贝出来，key是旧的结点，value的新拷贝出的结点。然后再遍历一遍旧的图，填充neighbors，即把结点连接起来。" />
          <outline text="代码" _note="/**&#10; * Definition for undirected graph.&#10; * struct UndirectedGraphNode {&#10; *     int label;&#10; *     vector&amp;lt;UndirectedGraphNode *&amp;gt; neighbors;&#10; *     UndirectedGraphNode(int x) : label(x) {};&#10; * };&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param node: A undirected graph node&#10;     * @return: A undirected graph node&#10;     */&#10;    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {&#10;        unordered_map&amp;lt;UndirectedGraphNode*, UndirectedGraphNode*&amp;gt; mapper;&#10;        queue&amp;lt;UndirectedGraphNode*&amp;gt; cache;&#10;        &#10;        if (node == NULL)&#10;            return node;&#10;            &#10;        cache.push(node);&#10;        cloneNode(node, mapper);&#10;        &#10;        while (!cache.empty()) {&#10;            int count = cache.size();&#10;            for (int i = 0; i &amp;lt; count; i++) {&#10;                UndirectedGraphNode* node = cache.front();&#10;                cloneNode(node, mapper);&#10;                cache.pop();&#10;                &#10;                for (int j = 0; j &amp;lt; node-&amp;gt;neighbors.size(); j++) {&#10;                    if (mapper.find(node-&amp;gt;neighbors[j]) == mapper.end())&#10;                        cache.push(node-&amp;gt;neighbors[j]);&#10;                }&#10;            }&#10;        }&#10;        &#10;        for (unordered_map&amp;lt;UndirectedGraphNode*, UndirectedGraphNode*&amp;gt;::iterator i = mapper.begin(); i != mapper.end(); i++) {&#10;            for (int j = 0; j &amp;lt; i-&amp;gt;first-&amp;gt;neighbors.size(); j++) {&#10;                i-&amp;gt;second-&amp;gt;neighbors.push_back(mapper[i-&amp;gt;first-&amp;gt;neighbors[j]]);&#10;            }&#10;        }&#10;        &#10;        return mapper[node];&#10;    }&#10;    &#10;    UndirectedGraphNode* cloneNode(UndirectedGraphNode* node, unordered_map&amp;lt;UndirectedGraphNode*, UndirectedGraphNode*&amp;gt;&amp;amp; mapper) {&#10;        UndirectedGraphNode* clonedNode = NULL;&#10;        if (mapper.find(node) == mapper.end()) {&#10;            clonedNode = new UndirectedGraphNode(node-&amp;gt;label);&#10;            mapper[node] = clonedNode;&#10;        }&#10;        else&#10;            clonedNode = mapper[node];&#10;        return clonedNode;&#10;    }&#10;};&#10;" /></outline>
        <outline text="n queens ii" >
          <outline text="描述" _note="同n queens问题，不同的是，n queens问题需要输出所有的棋子摆放可能，该问题只需要输出有多少种可能。" />
          <outline text="思路" _note="使用一个result变量存储最终的结果，在dfs的时候，到达叶子时result++，因为到达叶子就意味着一种摆放完成了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * Calculate the total number of distinct N-Queen solutions.&#10;     * @param n: The number of queens.&#10;     * @return: The total number of distinct solutions.&#10;     */&#10;    int totalNQueens(int n) {&#10;        vector&amp;lt;int&amp;gt; state(n, -1);&#10;        int result = 0;&#10;        dfs(0, n, state, result);&#10;        return result;&#10;    }&#10;    &#10;    void dfs(int curr, int n, vector&amp;lt;int&amp;gt;&amp;amp; state, int&amp;amp; result) {&#10;        if (curr == n) {&#10;            result++;&#10;            return;&#10;        }&#10;        &#10;        for (int colIndex = 0; colIndex &amp;lt; n; colIndex++) {&#10;            if (isValid(state, curr, colIndex)) {&#10;                state[curr] = colIndex;&#10;                dfs(curr + 1, n, state, result);&#10;                state[curr] = -1;&#10;            }                &#10;        }&#10;    }&#10;    &#10;    bool isValid(vector&amp;lt;int&amp;gt;&amp;amp; state, int rowIndex, int colIndex) {&#10;        for (int i = 0; i &amp;lt; rowIndex; i++) {&#10;            if (state[i] == colIndex || abs(state[i] - colIndex) == abs(i - rowIndex))&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Dynamic Programming" >
        <outline text="unique paths ii" >
          <outline text="描述" _note="有一个二维数组，0表示可以走，1表示不可以走，求所有可能的路线个数（从左上角走到右下角）。" />
          <outline text="思路" _note="先把dp初始化为全0，到i,j位置的所有路径数（i,j位置不为1)：if(dp[i - 1][j] == 0) dp[i][j] += dp[i - 1][j]; if（dp[i][j - 1] == 0) dp[i][j] += dp[i][j - 1]。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param obstacleGrid: A list of lists of integers&#10;     * @return: An integer&#10;     */ &#10;    int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;obstacleGrid) {&#10;        if (obstacleGrid.size() == 0 || obstacleGrid[0].size() == 0)&#10;            return 0;&#10;            &#10;        int m = obstacleGrid.size();&#10;        int n = obstacleGrid[0].size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 0));&#10;        &#10;        for (int i = 0; i &amp;lt; m; i++) {&#10;            for (int j = 0; j &amp;lt; n; j++) {&#10;                if (obstacleGrid[i][j] == 0) {&#10;                    if (i == 0 &amp;amp;&amp;amp; j == 0)&#10;                        dp[i][j] = 1;&#10;                    if (j &amp;gt; 0 &amp;amp;&amp;amp; obstacleGrid[i][j - 1] == 0)&#10;                        dp[i][j] += dp[i][j - 1];&#10;                    if (i &amp;gt; 0 &amp;amp;&amp;amp; obstacleGrid[i - 1][j] == 0)&#10;                        dp[i][j] += dp[i - 1][j];&#10;                }&#10;            }&#10;        }&#10;        &#10;        return dp[m - 1][n - 1];&#10;    }&#10;};&#10;" /></outline>
        <outline text="climbing stairs" >
          <outline text="描述" _note="有n个台阶，每次可以上1或2个，求总共有多少种上台阶的方法。" />
          <outline text="思路" _note="dp[i] = dp[i - 1] + dp[i - 2]，即第i个台阶可以从i-1一步上来，也可以从i-2两步上来。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param n: An integer&#10;     * @return: An integer&#10;     */&#10;    int climbStairs(int n) {&#10;        if (n == 0)&#10;            return 1;&#10;        if (n &amp;lt;= 2)&#10;            return n;&#10;        &#10;        vector&amp;lt;int&amp;gt; dp(n, 0);&#10;        dp[0] = 1;&#10;        dp[1] = 2;&#10;        for (int i = 2; i &amp;lt; n; i++) {&#10;            dp[i] = dp[i - 1] + dp[i - 2];&#10;        }&#10;        return dp[n - 1];&#10;    }&#10;};&#10;" /></outline>
        <outline text="triangle" >
          <outline text="描述" _note="[&#10;     [2],&#10;    [3,4],&#10;   [6,5,7],&#10;  [4,1,8,3]&#10;]，从三角形的最顶部走到最低部，经过的数字和最小，且每次走只能往相邻的方向走。" />
          <outline text="思路" _note="从下往上走，假设三角形的底部有x个元素，则开一个数组dp[x]，dp[j] = min(dp[j], dp[j + 1]) + triangle[current row index][j]。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param triangle: a list of lists of integers.&#10;     * @return: An integer, minimum path sum.&#10;     */&#10;    int minimumTotal(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;triangle) {&#10;        int row = triangle.size();&#10;        if (row == 0)&#10;            return 0;&#10;    &#10;        vector&amp;lt;int&amp;gt; dp(triangle[row - 1].size(), 0);&#10;        for (int i = row - 1; i &amp;gt;= 0; i--) {&#10;            for (int j = 0; j &amp;lt; triangle[i].size(); j++) {&#10;                if (i == row - 1)&#10;                    dp[j] = triangle[i][j];&#10;                else&#10;                    dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];&#10;            }&#10;        }&#10;        return dp[0];        &#10;    }&#10;};&#10;" /></outline>
        <outline text="maximum subarray" >
          <outline text="描述" _note="求数组的最大连续子数组，使得子数组的和最大。" />
          <outline text="思路" _note="使用dp[i]表示前0~i个子数组的和，dp[i] = dp[i] + dp[i - 1] if dp[i - 1] &amp;gt;= 0 else dp[i] + 0。还可以只使用一个变量dp，dp随着遍历数组而改变，只记录0~i的子数组的值，如果大于result（初始化为INT_MIN），则修改result。" />
          <outline text="代码一" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: A integer indicate the sum of max subarray&#10;     */&#10;    int maxSubArray(vector&amp;lt;int&amp;gt; nums) {&#10;        int n = nums.size();&#10;        if (n == 0)&#10;            return 0;&#10;            &#10;        vector&amp;lt;int&amp;gt; dp(n, 0);&#10;        int result = INT_MIN;&#10;        for (int i = 0; i &amp;lt; n; i++) {&#10;            if (i == 0)&#10;                dp[i] = nums[i];&#10;            else {&#10;                if (dp[i - 1] &amp;lt; 0)&#10;                    dp[i] = nums[i];&#10;                else&#10;                    dp[i] = dp[i - 1] + nums[i];&#10;            }&#10;            &#10;            if (dp[i] &amp;gt; result)&#10;                result = dp[i];&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" />
          <outline text="代码二" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: A integer indicate the sum of max subarray&#10;     */&#10;    int maxSubArray(vector&amp;lt;int&amp;gt; nums) {&#10;        int dp = 0;&#10;        int result = INT_MIN;&#10;        &#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            if (dp &amp;gt;= 0)&#10;                dp += nums[i];&#10;            else&#10;                dp = nums[i];&#10;            &#10;            if (dp &amp;gt; result)&#10;                result = dp;&#10;        }&#10;        return result;&#10;    }&#10;};" /></outline>
        <outline text="maximum product subarray" >
          <outline text="描述" _note="求数组的子数组，使得子数组的乘积最大。" />
          <outline text="思路" _note="遍历数组的时候存储当前索引下0~i的子数组乘积最大值dpMax和最小值dpMin，最大值肯定是从max(max(nums[i] * dpMax, nums[i] * dpMin), nums[i])中产生，即要么乘以之前的最大或最小值，要么是自己。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: a vector of integers&#10;     * @return: an integer&#10;     */&#10;    int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) {&#10;        int dpMin = 1;&#10;        int dpMax = 1;&#10;        int result = INT_MIN;&#10;        &#10;        for (int i = 0; i &amp;lt; nums.size(); i++) {&#10;            int tmp = max(max(nums[i] * dpMax, nums[i] * dpMin), nums[i]);&#10;            if (tmp &amp;gt; result)&#10;                result = tmp;&#10;                &#10;            int dpMinTmp = min(min(nums[i] * dpMin, nums[i] * dpMax), nums[i]);&#10;            int dpMaxTmp = max(max(nums[i] * dpMin, nums[i] * dpMax), nums[i]);&#10;            dpMin = dpMinTmp;&#10;            dpMax = dpMaxTmp;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="edit distance" >
          <outline text="描述" _note="计算2个字符串的编辑距离，一次插入、删除、替换记为距离1。" />
          <outline text="思路" _note="dp[i][j]表示两个字符串0~i和0~j子串的编辑距离。dp[i][j] = dp[i - 1][j - 1] if word1[i] == word2[j]这个很好理解，如果要比较的字符串尾部一样，就看前面的编辑距离。如果word1[i] != word2[j]，则可能存在3种情况：&#10;1. dp[i][j - 1] + 1，word1[0~i] == word2[0~j-1]，所以word1少一个字符，需要执行插入操作。&#10;2. 1 + dp[i - 1][j]，word1[0~i-1] == word2[0~j]，所以word1多一个字符，需要执行删除操作。&#10;3. dp[i - 1][j - 1] + 1，word1[0~i-1] == word2[0~j-1]，所以word1和word2只有最后一个字符不同，需要执行替换操作。&#10;将3者求min即可。" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param word1 &amp;amp; word2: Two string.&#10;     * @return: The minimum number of steps.&#10;     */&#10;    int minDistance(string word1, string word2) {&#10;        int m = word1.size();&#10;        int n = word2.size();&#10;        &#10;        if (m == 0)&#10;            return n;&#10;        if (n == 0)&#10;            return m;&#10;            &#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0));&#10;        for (int i = 0; i &amp;lt;= m; i++)&#10;            dp[i][0] = i;&#10;        for (int j = 0; j &amp;lt;= n; j++)&#10;            dp[0][j] = j;&#10;        &#10;        for (int i = 1; i &amp;lt;= m; i++) {&#10;            for (int j = 1; j &amp;lt;= n; j++) {&#10;                int replace = dp[i - 1][j - 1] + 1;&#10;                int remove = 1 + dp[i - 1][j];&#10;                int insert = dp[i][j - 1] + 1;&#10;                &#10;                if (word1[i - 1] == word2[j - 1])&#10;                    dp[i][j] = dp[i - 1][j - 1];&#10;                else&#10;                    dp[i][j] = min(min(replace, remove), insert);&#10;            }&#10;        }&#10;        return dp[m][n];&#10;    }&#10;};&#10;" /></outline>
        <outline text="distinct subsequences" >
          <outline text="描述" _note="从S删除若干字符变成T，有多少种删除方式。" />
          <outline text="思路" _note="dp[i][j]表示从S[0~i]变成T[0~j]的删除方式。如果S[i] != T[j]，则dp[i][j] = dp[i - 1][j]（只能通过S[0~i-1]变成T[0~j]）。如果S[i] == T[j]，则dp[i][j] = dp[i - 1][j - 1]（使用S[i]进行匹配） + dp[i - 1][j]（不使用S[i]进行匹配）。" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param S, T: Two string.&#10;     * @return: Count the number of distinct subsequences&#10;     */&#10;    int numDistinct(string &amp;amp;S, string &amp;amp;T) {&#10;        int m = S.size();&#10;        int n = T.size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0));&#10;        &#10;        for (int i = 0; i &amp;lt;= m; i++)&#10;            dp[i][0] = 1;&#10;            &#10;        for (int i = 1; i &amp;lt;= m; i++) {&#10;            for (int j = 1; j &amp;lt;= n; j++) {&#10;                if (S[i - 1] == T[j - 1])&#10;                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];&#10;                else&#10;                    dp[i][j] = dp[i - 1][j];&#10;            }&#10;        }&#10;        return dp[m][n];&#10;    }&#10;};&#10;" /></outline>
        <outline text="word break" >
          <outline text="描述" _note="给一个字符串，和一个字典，判断该字符串能否由字典的字符串组合而成。" />
          <outline text="思路" _note="dp[i] = dp[j] &amp;amp;&amp;amp; s.substr(k, i - k) in dict。其中，dp[i]表示前i个字符是否能由dict中的字符串组成，也就是s[0~i-1]，所以dp[0~N]有N+1个元素，dp[0]用于初始化，在这里dp[0]该初始化成几呢？dp[1] = dp[0] &amp;amp;&amp;amp; s.substr(..) in dict。所以，dp[0] = true，如果是false，dp[1]就不对了。这个思路会超时，主要是因为2重循环。&#10;然后就有了第二种方法，即代码二。不同之处是，在内层循环，对dict进行遍历，这样会减少无用功，原来可是一个字符一个字符的尝试，现在是按照dict中字符串的长度进行尝试，明显提高了命中率。" />
          <outline text="代码一（超时）" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param s: A string s&#10;     * @param dict: A dictionary of words dict&#10;     */&#10;    bool wordBreak(string s, unordered_set&amp;lt;string&amp;gt; &amp;amp;dict) {&#10;        int n = s.size();&#10;      &#10;        vector&amp;lt;bool&amp;gt; dp(n + 1, false);&#10;        dp[0] = true;&#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            for (int j = 0; j &amp;lt; i; j++) {&#10;                dp[i] = dp[j] &amp;amp;&amp;amp; dict.find(s.substr(j, i - j)) != dict.end();&#10;                if (dp[i])&#10;                    break;&#10;            }&#10;        }&#10;        return dp[n];&#10;    }&#10;};&#10;" />
          <outline text="代码二" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param s: A string s&#10;     * @param dict: A dictionary of words dict&#10;     */&#10;    bool wordBreak(string s, unordered_set&amp;lt;string&amp;gt; &amp;amp;dict) {&#10;        int n = s.size();&#10;      &#10;        vector&amp;lt;bool&amp;gt; dp(n + 1, false);&#10;        dp[0] = true;&#10;        for (int i = 0; i &amp;lt;= n; i++) {&#10;            if (dp[i]) {&#10;                for (unordered_set&amp;lt;string&amp;gt;::iterator j = dict.begin(); j != dict.end(); j++) {&#10;                    if (dict.find(s.substr(i, (*j).size())) != dict.end())&#10;                        dp[i + (*j).size()] = true;&#10;                }&#10;            }&#10;        }&#10;        return dp[n];&#10;    }&#10;};&#10;" /></outline>
        <outline text="backpack" >
          <outline text="描述" _note="背包问题，给定一个数组，代表物品大小；还有一个值，代码书包的大小。求书包可以放的最多的物品个数。" />
          <outline text="思路" _note="dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - A[i - 1]] + A[i - 1]}，其中，dp[i][j]表示从前i个物品中blabla，最后书包放下的最大数目存在dp[i][j]中。对于N个物品，dp[0~N][.]的行又“牺牲”了第0行，但是这样会方便许多。同时，把转移方程变成：dp[i + 1][j] = max{dp[i][j], dp[i][j - A[i]] + A[i]},在循环的时候，i from 0 to N - 1，j from - to M。还需要确定dp[0][.]的值，因为dp[1][.]完全依赖dp[0][.]算出来，dp[0][.]表示前0个物品，即没有物品，所以dp[0][.]全初始为0。按照此方法的代码一超时了。原因在于使用的dp是二维数组。&#10;解决方法使用一维的数组。在上面有写到，“dp[1][.]完全依赖dp[0][.]算出来”，即dp[i+1][.]完全依赖于dp[i][.]，所以我们可以这样，只用一个dp[1 + M]的数组，随着按行遍历，先写dp[0][.]的结果，然后再覆盖写dp[1][.]的结果，以此类推，只要保证在写的时候，需要用的上一行的值还没有被覆盖就可以了。从dp[i + 1][j] = max{dp[i][j], dp[i][j - A[i]] + A[i]}中可以发现，dp[.][j]依赖于dp[.][j]和dp[.][j - x]，所以只要我们从dp[1 + M]的右边开始写，就妥妥的没问题了！所以，dp[j] = max(dp[j], dp[j - A[i]] + A[i]}，需要注意，如果j &amp;lt; A[i]，那么就不用更新dp[j]了，使用上一行的即可。" />
          <outline text="代码一（超时）" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param m: An integer m denotes the size of a backpack&#10;     * @param A: Given n items with size A[i]&#10;     * @return: The maximum size&#10;     */&#10;    int backPack(int m, vector&amp;lt;int&amp;gt; A) {&#10;        int n = A.size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(1 + n, vector&amp;lt;int&amp;gt;(1 + m, 0));&#10;        &#10;        for (int i = 0; i &amp;lt; n; i++) {&#10;            for (int j = 0; j &amp;lt;= m; j++) {&#10;                if (j &amp;lt; A[i])&#10;                    dp[i + 1][j] = dp[i][j];&#10;                else&#10;                    dp[i + 1][j] = max(dp[i][j], dp[i][j - A[i]] + A[i]);&#10;            }&#10;        }&#10;        return dp[n][m];&#10;    }&#10;};" />
          <outline text="代码二" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param m: An integer m denotes the size of a backpack&#10;     * @param A: Given n items with size A[i]&#10;     * @return: The maximum size&#10;     */&#10;    int backPack(int m, vector&amp;lt;int&amp;gt; A) {&#10;        int n = A.size();&#10;        vector&amp;lt;int&amp;gt; dp(1 + m, 0);&#10;        &#10;        for (int i = 0; i &amp;lt; n; i++) {&#10;            for (int j = m; j &amp;gt;= A[i]; j--) {&#10;                dp[j] = max(dp[j], dp[j - A[i]] + A[i]);&#10;            }&#10;        }&#10;        return dp[m];&#10;    }&#10;};&#10;" /></outline>
        <outline text="interleaving string" >
          <outline text="描述" _note="有3个字符串s1、s2、s3，判断s3是否有s1和s2交叉组成。所谓的交叉就是，先从s1取若干字符，再从s2取若干字符，再从s1取若干字符，以此类推。" />
          <outline text="思路" _note="dp[i][j] = (dp[i - 1][j] &amp;amp;&amp;amp; s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] &amp;amp;&amp;amp; s1[j - 1] == s3[i + j - 1])，其中dp[i][j]表示s1前i个字符和s2前j个字符能否组成s3的前i+j个字符。这里需要确定dp[0][.]和dp[.][0]是多少。对于dp[0][.]相当于只使用s2，所以dp[0][j] = dp[0][j - 1] &amp;amp;&amp;amp; s2[j - 1] == s3[0+j-1]，dp[.][0]同理。所以，最后归结为dp[0][0]是多少呢？dp[0][1] = dp[0][0] &amp;amp;&amp;amp; s2[0] == s3[0]，只需要判断s2的第一个元素是否和s3的第一个元素相等即可，所以dp[0][0]赋值为true。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * Determine whether s3 is formed by interleaving of s1 and s2.&#10;     * @param s1, s2, s3: As description.&#10;     * @return: true of false.&#10;     */&#10;    bool isInterleave(string s1, string s2, string s3) {&#10;        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();&#10;        if (n1 + n2 != n3)&#10;            return false;&#10;            &#10;        vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; dp(n1 + 1, vector&amp;lt;bool&amp;gt;(n2 + 1, false));&#10;        dp[0][0] = true;        &#10;        for (int i = 1; i &amp;lt;= n1; i++)&#10;            if (s1[i - 1] == s3[i - 1] &amp;amp;&amp;amp; (i == 1 || dp[i - 1][0]))&#10;                dp[i][0] = true;&#10;        for (int j = 1; j &amp;lt;= n2; j++)&#10;            if (s2[j - 1] == s3[j - 1] &amp;amp;&amp;amp; (j == 1 || dp[0][j - 1]))&#10;                dp[0][j] = true;&#10;        &#10;        for (int i = 1; i &amp;lt;= n1; i++) {&#10;            for (int j = 1; j &amp;lt;= n2; j++) {&#10;                dp[i][j] = (dp[i - 1][j] &amp;amp;&amp;amp; s1[i - 1] == s3[i + j - 1])&#10;                    || (dp[i][j - 1] &amp;amp;&amp;amp; s2[j - 1] == s3[i + j - 1]);&#10;            }&#10;        }&#10;        return dp[n1][n2];&#10;    }&#10;};&#10;&#10;" /></outline>
        <outline text="minimum subarray" >
          <outline text="描述" _note="求数组的子数组，使其和最小。" />
          <outline text="思路" _note="随着遍历数组，dpMin表示当前（以i结尾的子数组）最小的和。如果dpMin = min(nums[i] + dpMin, nums[i])。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: a list of integers&#10;     * @return: A integer denote the sum of minimum subarray&#10;     */&#10;    int minSubArray(vector&amp;lt;int&amp;gt; nums) {&#10;        int n = nums.size();&#10;        int dpMin = 0;&#10;        int result = INT_MAX;&#10;        for (int i = 0; i &amp;lt; n; i++) {&#10;            dpMin = min(dpMin + nums[i], nums[i]);&#10;            &#10;            if (dpMin &amp;lt; result)&#10;                result = dpMin;&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="- minimum adjustment cost" >
          <outline text="描述" _note="给定一个数字数组（元素大于等于0且小于等于100），将其各个元素进行调整，使得相邻元素不超过target值，求最小的调整代价。" />
          <outline text="思路" _note="dp[i][j] = min{dp[i - 1][k], k ∈ range(max{0, j - target}, min{100, j + target})} + abs(A[i] - j)，其中，dp[i][j]表示A[i]变成j且保证相邻元素不超过target需要的最小代价。所以，遍历dp[N-1][.]可以得到dp[N-1][k]，即为最后的结果。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A: An integer array.&#10;     * @param target: An integer.&#10;     */&#10;    int MinAdjustmentCost(vector&amp;lt;int&amp;gt; A, int target) {&#10;        int n = A.size();&#10;        const int m = 100;&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(n, vector&amp;lt;int&amp;gt;(m + 1, INT_MAX));&#10;        &#10;        for (int j = 0; j &amp;lt;= m; j++)&#10;            dp[0][j] = abs(A[0] - j);&#10;        &#10;        for (int i = 1; i &amp;lt; n; i++) {&#10;            for (int j = 0; j &amp;lt;= m; j++) {&#10;                for (int k = max(0, j - target); k &amp;lt;= min(m, j + target); k++)&#10;                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(A[i] - j));&#10;            }&#10;        }&#10;        &#10;        int result = INT_MAX;&#10;        for (int j = 0; j &amp;lt;= m; j++)&#10;            result = min(result, dp[n - 1][j]);            &#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="longest common substring" >
          <outline text="描述" _note="求给定字符串A、B的最长公共子串，子串要求在字符串中连续。" />
          <outline text="思路" _note="dp[i][j]表示A的前i个字符和B的前j个字符求得的公共子串长度，这里要求公共子串的尾部必须是A的第i个元素和B的第j个元素，即A[i - 1] == B[j - 1]。所以，dp[i][j] = dp[i - 1][j - 1] + 1 if A[i - 1] == B[j - 1] else 0" />
          <outline text="代码" _note="class Solution {&#10;public:    &#10;    /**&#10;     * @param A, B: Two string.&#10;     * @return: the length of the longest common substring.&#10;     */&#10;    int longestCommonSubstring(string &amp;amp;A, string &amp;amp;B) {&#10;        int m = A.size(), n = B.size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0));&#10;        int result = 0;&#10;        &#10;        for (int i = 1; i &amp;lt;= m; i++) {&#10;            for (int j = 1; j &amp;lt;= n; j++) {&#10;                if (A[i - 1] == B[j - 1])&#10;                    dp[i][j] = dp[i - 1][j - 1] + 1;&#10;                result = max(dp[i][j], result);&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="longest common subsequence" >
          <outline text="描述" _note="计算A和B的最长公共子序列，子序列无需在A或B中连续。" />
          <outline text="思路" _note="dp[i][j]表示A的前i个字符和B的前j个字符求得的最长公共子序列长度。dp[i][j] = dp[i - 1][j - 1] + 1 if A[i - 1] == B[j - 1] else max{dp[i - 1][j], dp[i][j - 1]}。当A[i - 1] == B[j - 1]时，可以直接加上dp[i - 1][j - 1]，因为此时肯定能让子序列更长。否则，dp[i][j] = max{dp[i][j - 1], dp[i - 1][j]}，因为A[i - 1]和B[j - 1]肯定是无法称为子序列的最后一个字符了，所以只能通过max选一个。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param A, B: Two strings.&#10;     * @return: The length of longest common subsequence of A and B.&#10;     */&#10;    int longestCommonSubsequence(string A, string B) {&#10;        int m = A.size(), n = B.size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0));&#10;        &#10;        for (int i = 1; i &amp;lt;= m; i++) {&#10;            for (int j = 1; j &amp;lt;= n; j++) {&#10;                dp[i][j] = A[i - 1] == B[j - 1]&#10;                    ? dp[i - 1][j - 1] + 1&#10;                    : max(dp[i - 1][j], dp[i][j - 1]);&#10;            }&#10;        }&#10;        return dp[m][n];&#10;    }&#10;};&#10;" /></outline>
        <outline text="longest increasing subsequence" >
          <outline text="描述" _note="计算数字数组的最长递增序列长度，例如：[5, 4, 1, 2, 3]的最长递增序列为[1, 2, 3]，[4, 2, 4, 5, 3, 7]的最长递增序列为[4, 4, 5, 7]。" />
          <outline text="思路" _note="dp[i]表示前i个数字所对应的最长递增子序列长度。所以，要想得到最长的，需要遍历dp[.]，然后找个一个最长的dp[i]。下一个问题是，如何计算dp[i]呢？dp[i] = max{dp[j], j &amp;lt; i &amp;amp;&amp;amp; dp[j] &amp;lt;= dp[i]} + 1，即遍历dp[i]之前的每一个，然后看dp[j]是不是&amp;lt;=dp[i]，如果是，则太棒啦，dp[i]有可能等于dp[j] + 1，所以要用max选择一个。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: The integer array&#10;     * @return: The length of LIS (longest increasing subsequence)&#10;     */&#10;    int longestIncreasingSubsequence(vector&amp;lt;int&amp;gt; nums) {&#10;        int n = nums.size();&#10;        vector&amp;lt;int&amp;gt; dp(n + 1, 0);&#10;        int result = 0;&#10;        &#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            int tmp = 0;&#10;            for (int j = 1; j &amp;lt; i; j++) {&#10;                if (nums[j - 1] &amp;lt;= nums[i - 1])&#10;                    tmp = max(dp[j], tmp);&#10;            }&#10;            dp[i] = tmp + 1;&#10;            result = max(dp[i], result);&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="maximum subarray difference" >
          <outline text="描述" _note="从给定数字数组从取两个子数组A和B（不相交），使得其abs(sum(A) - sum(B))最大。" />
          <outline text="思路" _note="minOfLeft[i]表示前i个元素的子数组的最小和，maxOfLeft[i]表示前i个元素的子数组的最大和。minOfRight、maxOfRight同理。要想abs(sum(A) - sum(B))最大，则A最小B最大或者A最大B最小。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: An integer indicate the value of maximum difference between two&#10;     *          Subarrays&#10;     */&#10;    int maxDiffSubArrays(vector&amp;lt;int&amp;gt; nums) {&#10;        int n = nums.size();&#10;        vector&amp;lt;int&amp;gt; minOfLeft(n + 1, 0);&#10;        vector&amp;lt;int&amp;gt; maxOfLeft(n + 1, 0);&#10;        vector&amp;lt;int&amp;gt; minOfRight(n + 1, 0);&#10;        vector&amp;lt;int&amp;gt; maxOfRight(n + 1, 0);&#10;        &#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            minOfLeft[i] = min(nums[i - 1], minOfLeft[i - 1] + nums[i - 1]);&#10;            maxOfLeft[i] = max(nums[i - 1], maxOfLeft[i - 1] + nums[i - 1]);&#10;        }&#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            minOfRight[i] = min(nums[n - i], minOfRight[i - 1] + nums[n - i]);&#10;            maxOfRight[i] = max(nums[n - i], maxOfRight[i - 1] + nums[n - i]);&#10;        }&#10;        &#10;        int result = 0;&#10;        for (int i = 1; i &amp;lt; n; i++) {&#10;            result = max(abs(minOfLeft[i] - maxOfRight[n - i]), result);&#10;            result = max(abs(maxOfLeft[i] - minOfRight[n - i]), result);&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="maximum subarray ii" >
          <outline text="描述" _note="从整数数组中选择2个子数组A、B（不相交），使得sum(A)+sum(B)最大。" />
          <outline text="思路" _note="先求maxOfLeft[i]，即前i个字符中子数组的最大和（子数组以i为结尾），maxOfRight[i]同理。再修改maxOfLeft和maxOfRight，因为maxOfLeft[i]存储的不是前i个元素中的子数组，而是以i结尾的，修改后maxOfLeft存储前i个元素和最大的子数组。maxOfRight[i]同理。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return: An integer denotes the sum of max two non-overlapping subarrays&#10;     */&#10;    int maxTwoSubArrays(vector&amp;lt;int&amp;gt; nums) {&#10;        int n = nums.size();&#10;        vector&amp;lt;int&amp;gt; maxOfLeft(n + 1, 0);&#10;        vector&amp;lt;int&amp;gt; maxOfRight(n + 1, 0);&#10;        &#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            maxOfLeft[i] = max(nums[i - 1], maxOfLeft[i - 1] + nums[i - 1]);&#10;        }&#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            maxOfRight[i] = max(nums[n - i], maxOfRight[i - 1] + nums[n - i]);&#10;        }&#10;        &#10;        int peak = INT_MIN;&#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            if (maxOfLeft[i] &amp;gt; peak)&#10;                peak = maxOfLeft[i];&#10;            else&#10;                maxOfLeft[i] = peak;&#10;        }&#10;        peak = INT_MIN;&#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            if (maxOfRight[i] &amp;gt; peak)&#10;                peak = maxOfRight[i];&#10;            else&#10;                maxOfRight[i] = peak;&#10;        }&#10;        &#10;        int result = INT_MIN;&#10;        for (int i = 1; i &amp;lt; n; i++) {&#10;            result = max(maxOfLeft[i] + maxOfRight[n - i], result);&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
        <outline text="- maximum subarray iii" >
          <outline text="描述" _note="给定一个数字数组，从中选择k个子数组（不相交），使得这k个子数组的和最大。" />
          <outline text="思路" _note="dp[i][j]表示从前i个元素中取j个子数组求得的结果。dp[i][j] = max{dp[p][j - 1] + maxSubArray(A[p~END], 1), j - 1 &amp;lt;= p &amp;lt;= i - 1}。for (int p = i - 1; p &amp;gt;= j - 1; p--)这个为啥从后往前遍历，还没搞明白+_+" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @param k: An integer denote to find k non-overlapping subarrays&#10;     * @return: An integer denote the sum of max k non-overlapping subarrays&#10;     */&#10;    int maxSubArray(vector&amp;lt;int&amp;gt; nums, int k) {&#10;        int n = nums.size();&#10;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(n + 1, vector&amp;lt;int&amp;gt;(k + 1, 0));&#10;        &#10;        for (int i = 1; i &amp;lt;= n; i++) {&#10;            for (int j = 1; j &amp;lt;= k; j++) {&#10;                dp[i][j] = INT_MIN;&#10;                int tmp = 0;&#10;                int maxOfRight = INT_MIN;&#10;                for (int p = i - 1; p &amp;gt;= j - 1; p--) {&#10;                    tmp = max(nums[p], tmp + nums[p]);&#10;                    maxOfRight = max(tmp, maxOfRight);&#10;                    if (dp[i][j] &amp;lt; dp[p][j - 1] + maxOfRight)&#10;                        dp[i][j] = dp[p][j - 1] + maxOfRight;&#10;                }&#10;            }&#10;        }&#10;        return dp[n][k];&#10;    }&#10;};&#10;" /></outline>
      </outline>
      <outline text="Data Structure" >
        <outline text="longest consecutive sequence" >
          <outline text="描述" _note="计算无序数字数组的最长连续序列，例如，[100, 4, 200, 1, 3, 2]的序列为[1, 2, 3, 4]，一共4个，返回4。" />
          <outline text="思路" _note="先一次遍历把所有的数字放到哈希表，key为数字，value为true，value表示该数字还未被使用。然后再次遍历数组，对于num[i]尝试去哈希表寻找num[i]±x，如果有则把哈希表对应值置为false，并将结果加1。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers&#10;     * @return an integer&#10;     */&#10;    int longestConsecutive(vector&amp;lt;int&amp;gt; &amp;amp;num) {&#10;        int n = num.size();&#10;        unordered_map&amp;lt;int, bool&amp;gt; cache;&#10;        for (int i = 0; i &amp;lt; n; i++)&#10;            cache[num[i]] = true;&#10;        &#10;        int result = 0;&#10;        for (unordered_map&amp;lt;int, bool&amp;gt;::iterator i = cache.begin(); i != cache.end(); i++) {&#10;            int value = i-&amp;gt;first;&#10;            int tmp = 0;&#10;            while (cache.find(value) != cache.end() &amp;amp;&amp;amp; cache[value]) {&#10;                cache[value--] = false;&#10;                tmp++;&#10;            }&#10;            value = i-&amp;gt;first + 1;&#10;            while (cache.find(value) != cache.end() &amp;amp;&amp;amp; cache[value]) {&#10;                cache[value++] = false;&#10;                tmp++;&#10;            }&#10;            result = max(tmp, result);&#10;        }&#10;        return result;&#10;    }&#10;};&#10;&#10;" /></outline>
        <outline text="merge k sorted lists" >
          <outline text="描述" _note="合并k个有序的链表。" />
          <outline text="思路" _note="使用mergesort的方法，递归合并。" />
          <outline text="代码" _note="/**&#10; * Definition of ListNode&#10; * class ListNode {&#10; * public:&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int val) {&#10; *         this-&amp;gt;val = val;&#10; *         this-&amp;gt;next = NULL;&#10; *     }&#10; * }&#10; */&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param lists: a list of ListNode&#10;     * @return: The head of one sorted list.&#10;     */&#10;    ListNode *mergeKLists(vector&amp;lt;ListNode *&amp;gt; &amp;amp;lists) {&#10;        return _mergeKLists(lists, 0, lists.size() - 1);&#10;    }&#10;    ListNode* _mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists, int from, int to) {&#10;        if (from &amp;gt; to)&#10;            return NULL;&#10;        if (from == to)&#10;            return lists[from];&#10;        &#10;        int mid = (from + to) / 2;&#10;        ListNode* list1 = _mergeKLists(lists, from, mid);&#10;        ListNode* list2 = _mergeKLists(lists, mid + 1, to);&#10;        &#10;        ListNode dummy;&#10;        ListNode* p = &amp;amp;dummy;&#10;        while (list1 != NULL || list2 != NULL) {&#10;            if (list1 != NULL &amp;amp;&amp;amp; list2 != NULL) {&#10;                if (list1-&amp;gt;val &amp;lt;= list2-&amp;gt;val) {&#10;                    p-&amp;gt;next = list1;&#10;                    list1 = list1-&amp;gt;next;&#10;                }&#10;                else {&#10;                    p-&amp;gt;next = list2;&#10;                    list2 = list2-&amp;gt;next;&#10;                }&#10;            }&#10;            else if (list1 != NULL) {&#10;                p-&amp;gt;next = list1;&#10;                list1 = list1-&amp;gt;next;&#10;            }&#10;            else if (list2 != NULL) {&#10;                p-&amp;gt;next = list2;&#10;                list2 = list2-&amp;gt;next;&#10;            }&#10;            p = p-&amp;gt;next;&#10;        }&#10;        p-&amp;gt;next = NULL;&#10;        return dummy.next;&#10;    }&#10;};" /></outline>
        <outline text="implement queue by two stacks" >
          <outline text="描述" _note="使用2个栈实现队列。" />
          <outline text="思路" _note="使用stack1和stack2，所有的push操作入stack1。如果pop，则将stack1的元素pop出并依次入stack2，然后再从stack2中pop。这里需要判断一下，如果stack2不空，则无需从stack1中pop，直接把stack2的pop出即可。" />
          <outline text="代码" _note="class Queue {&#10;public:&#10;    stack&amp;lt;int&amp;gt; stack1;&#10;    stack&amp;lt;int&amp;gt; stack2;&#10;&#10;    Queue() {&#10;    }&#10;&#10;    void push(int element) {&#10;        stack1.push(element);&#10;    }&#10;&#10;    int getTopFromDummyQueue() {&#10;        int value;&#10;        if (!stack2.empty()) {&#10;            value = stack2.top();&#10;        }&#10;        else {&#10;            while (!stack1.empty()) {&#10;                stack2.push(stack1.top());&#10;                stack1.pop();&#10;            }&#10;            value = stack2.top();&#10;        }&#10;        return value;&#10;    }    &#10;    &#10;    int pop() {&#10;        int value = getTopFromDummyQueue();&#10;        stack2.pop();&#10;        return value;&#10;    }&#10;&#10;    int top() {&#10;        return getTopFromDummyQueue();&#10;    }&#10;};&#10;" /></outline>
        <outline text="min stack" >
          <outline text="描述" _note="实现一个有min操作的栈，即可以获得栈中最小的元素。" />
          <outline text="思路" _note="使用realStack和minStack分别为真实的栈和存放最小值的栈。每次push，都直接push到realStack，如果number比minStack的栈顶小或相等，则也push到minStack（如果minStack为空也push进去）。pop的时候，realStack直接pop，然后判断pop出的元素与minStack栈顶是否相等，相等则也pop。这里需要注意，push到minStack的条件，等于minStack栈顶的时候也要push，因为可能会push一堆相同的数字，如果只在minStack存一个的话，pop的时候就不好办了。" />
          <outline text="代码" _note="class MinStack {&#10;public:&#10;    stack&amp;lt;int&amp;gt; realStack;&#10;    stack&amp;lt;int&amp;gt; minStack;&#10;    &#10;    MinStack() {&#10;    }&#10;&#10;    void push(int number) {&#10;        realStack.push(number);&#10;        if (minStack.empty() || minStack.top() &amp;gt;= number)&#10;            minStack.push(number);&#10;    }&#10;&#10;    int pop() {&#10;        int value = realStack.top();&#10;        realStack.pop();&#10;        if (value == minStack.top())&#10;            minStack.pop();&#10;        return value;&#10;    }&#10;&#10;    int min() {&#10;        return minStack.top();&#10;    }&#10;};" /></outline>
        <outline text="ugly number" >
          <outline text="描述" _note="ugly number是3、5、7相互组合（乘法）的一个序列，数字依次增大（不重复），第一个为2。" />
          <outline text="思路" _note="有2个方法，分别对应于代码一和代码二。&#10;方法一，使用的是“竞争策略”，dp[0]=1，然后让3、5、7分别去乘以dp[0]，最后3*dp[0]最小，所以竞争成功，即dp[1]=2；下一轮中，5、7去乘以dp[0]，2应该乘以dp[1]了，以此类推。需要注意代码中的if是并列的，不能用else，因为dp[i]可能对于3或5都可以进行计算得到。&#10;方法二，使用最小堆，每次从堆里取出最小的值与3、5、7相乘，然后再放入堆中，期间需要用一个set来存放序列记录防止重复。" />
          <outline text="代码一" _note="class Solution {&#10;public:&#10;    /*&#10;     * @param k: The number k.&#10;     * @return: The kth prime number as description.&#10;     */&#10;    long long kthPrimeNumber(int k) {&#10;        vector&amp;lt;long long&amp;gt; dp(k + 1, 1);&#10;        int k3 = 0, k5 = 0, k7 = 0;&#10;        for (int i = 1; i &amp;lt;= k; i++) {&#10;            dp[i] = min(min(dp[k3] * 3, dp[k5] * 5), dp[k7] * 7);&#10;            if (dp[i] == dp[k3] * 3)&#10;                k3++;&#10;            if (dp[i] == dp[k5] * 5)&#10;                k5++;&#10;            if (dp[i] == dp[k7] * 7)&#10;                k7++;&#10;        }&#10;        return dp[k];&#10;    }&#10;};" />
          <outline text="代码二" _note="class Solution {&#10;public:&#10;    /*&#10;     * @param k: The number k.&#10;     * @return: The kth prime number as description.&#10;     */&#10;    long long kthPrimeNumber(int k) {&#10;        const int factors[] = {3, 5, 7};&#10;        priority_queue&amp;lt;long long, vector&amp;lt;long long&amp;gt;, greater&amp;lt;long long&amp;gt; &amp;gt; minHeap;&#10;        unordered_set&amp;lt;long long&amp;gt; cache;&#10;        minHeap.push(1);&#10;        cache.insert(1);&#10;        &#10;        for (int i = 0; ; i++) {&#10;            long long minItem = minHeap.top();&#10;            minHeap.pop();&#10;            if (i == k)&#10;                return minItem;&#10;                &#10;            for (int j = 0; j &amp;lt; 3; j++) {&#10;                long long tmp = minItem * factors[j];&#10;                if (cache.find(tmp) == cache.end()) {&#10;                    minHeap.push(tmp);&#10;                    cache.insert(tmp);&#10;                }&#10;            }&#10;        }&#10;        return 0;//never be here&#10;    }&#10;};" /></outline>
        <outline text="word search ii" >
          <outline text="描述" _note="从字符表中寻找给定的词表中的词，只能向左、向右、向上、向下查找。例如，&#10;[doaf,&#10;agai,&#10;dcan]，给定{&quot;dog&quot;, &quot;dad&quot;, &quot;dgdg&quot;, &quot;can&quot;, &quot;again&quot;}，则返回{&quot;dog&quot;, &quot;dad&quot;, &quot;can&quot;, &quot;again&quot;}。&#10;" />
          <outline text="思路" _note="使用Trie，即前缀树，对于英文字母来说，每一个结点有26个孩子，分别表示字符a~z。使用dfs进行查找，当当前字符串在Trie中，才进一步判断是否存在该字符，否则直接返回。需要使用visited[.]数组来记录某个单元格是否被访问，比如，对某个单元格dfs时，先要将该单元格的visited置为true，这样防止后面的dfs又搜索到当前单元格。最后把visited还原成false。" />
          <outline text="代码" _note="class TrieNode {&#10;public:&#10;    bool isWord;&#10;    vector&amp;lt;TrieNode*&amp;gt; children;&#10;    TrieNode():isWord(false), children(26, NULL) {}&#10;};&#10;class Trie {&#10;public:&#10;    TrieNode root;&#10;    Trie(vector&amp;lt;string&amp;gt;&amp;amp; words) {&#10;        for (int i = 0; i &amp;lt; words.size(); i++)&#10;            add(words[i]);&#10;    }&#10;    &#10;    void add(string word) {&#10;        TrieNode* node = &amp;amp;root;&#10;        for (int i = 0; i &amp;lt; word.size(); i++) {&#10;            if (node-&amp;gt;children[word[i] - 'a'] == NULL)&#10;                node-&amp;gt;children[word[i] - 'a'] = new TrieNode();&#10;            node = node-&amp;gt;children[word[i] - 'a'];&#10;        }&#10;        node-&amp;gt;isWord = true;&#10;    }&#10;    &#10;    bool containsWord(string&amp;amp; word) {&#10;        TrieNode* node = &amp;amp;root;&#10;        for (int i = 0; i &amp;lt; word.size(); i++) {&#10;            if (node-&amp;gt;children[word[i] - 'a'] == NULL)&#10;                return false;&#10;            node = node-&amp;gt;children[word[i] - 'a'];&#10;        }&#10;        if (node-&amp;gt;isWord)&#10;            return true;&#10;        return false;&#10;    }&#10;    &#10;    bool startsWith(string&amp;amp; word) {&#10;        TrieNode* node = &amp;amp;root;&#10;        for (int i = 0; i &amp;lt; word.size(); i++) {&#10;            if (node-&amp;gt;children[word[i] - 'a'] == NULL)&#10;                return false;&#10;            node = node-&amp;gt;children[word[i] - 'a'];&#10;        }&#10;        return true;&#10;    }&#10;};&#10;&#10;class Solution {&#10;public:&#10;    /**&#10;     * @param board: A list of lists of character&#10;     * @param words: A list of string&#10;     * @return: A list of string&#10;     */&#10;    vector&amp;lt;string&amp;gt; wordSearchII(vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt; &amp;amp;board, vector&amp;lt;string&amp;gt; &amp;amp;words) {&#10;        Trie trie(words);&#10;        set&amp;lt;string&amp;gt; result;&#10;        vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; visited(board.size(), vector&amp;lt;bool&amp;gt;(board[0].size(), false));&#10;        for (int i = 0; i &amp;lt; board.size(); i++) {&#10;            for (int j = 0; j &amp;lt; board[0].size(); j++) {&#10;                dfs(board, i, j, visited, trie, &quot;&quot;, result);&#10;            }&#10;        }&#10;        return vector&amp;lt;string&amp;gt;(result.begin(), result.end());&#10;    }&#10;    &#10;    void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt;&amp;amp; board, int x, int y, vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt;&amp;amp; visited, Trie&amp;amp; trie, string word, set&amp;lt;string&amp;gt;&amp;amp; result) {&#10;        if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= board.size() || y &amp;gt;= board[0].size())&#10;            return;&#10;        if (visited[x][y])&#10;            return;&#10;            &#10;        word += board[x][y];&#10;        if (!trie.startsWith(word))&#10;            return;&#10;            &#10;        if (trie.containsWord(word))&#10;            result.insert(word);&#10;&#10;        visited[x][y] = true;&#10;        dfs(board, x, y + 1, visited, trie, word, result);&#10;        dfs(board, x, y - 1, visited, trie, word, result);&#10;        dfs(board, x + 1, y, visited, trie, word, result);&#10;        dfs(board, x - 1, y, visited, trie, word, result);&#10;        visited[x][y] = false;&#10;    }&#10;};" /></outline>
        <outline text="largest rectangle in histogram" >
          <outline text="描述" _note="直方图中的最大矩形。" />
          <outline text="思路" _note="可以观察到一个特性，即如果height[i]比height[i - 1]大，则i - 1的位置肯定不是矩形的右端点。即，当height[i] &amp;gt; height[i - 1]的时候，就会不断遍历左端点，选一个max。具体为使用一个栈来存储左侧的所有下标，不断pop然后计算。需要给height.push_back(-1)，否则的话[1,2,3]这样的case就没法算了。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param height: A list of integer&#10;     * @return: The area of largest rectangle in the histogram&#10;     */&#10;    int largestRectangleArea(vector&amp;lt;int&amp;gt; height) {&#10;        if (height.size() == 0)&#10;            return 0;&#10;            &#10;        stack&amp;lt;int&amp;gt; cache;&#10;        height.push_back(-1);&#10;        int maxArea = 0;&#10;        for (int i = 0; i &amp;lt; height.size(); i++) {&#10;            while (!cache.empty() &amp;amp;&amp;amp; height[i] &amp;lt;= height[cache.top()]) {&#10;                int h = height[cache.top()];&#10;                cache.pop();&#10;                maxArea = cache.size() != 0&#10;                    ? max(maxArea, (i - cache.top() - 1) * h)&#10;                    : max(maxArea, i * h);&#10;            }&#10;            cache.push(i);&#10;        }&#10;        return maxArea;&#10;    }&#10;};&#10;" /></outline>
        <outline text="data stream median" >
          <outline text="描述" _note="不断读入数字，求截止到当前数字的中位数。" />
          <outline text="思路" _note="使用2个堆，最大堆存放前排序后的n/2的数字，最小堆存放n/2后的数字。对于奇数个数字，最大堆则多存储一个。为了保证这个存放规则，所有来的数字，如果比maxHeap的堆顶小，则放到大堆，否则放到小堆，然后判断大堆和小堆的存放数目，看需不需要调整。如果大堆的数字多了，就取堆顶元素放到小堆，小堆同理。" />
          <outline text="代码" _note="class Solution {&#10;public:&#10;    /**&#10;     * @param nums: A list of integers.&#10;     * @return: The median of numbers&#10;     */&#10;    vector&amp;lt;int&amp;gt; medianII(vector&amp;lt;int&amp;gt; &amp;amp;nums) {&#10;        vector&amp;lt;int&amp;gt; result;&#10;        int n = nums.size();&#10;        if (n == 0)&#10;            return result;&#10;            &#10;        priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt; &amp;gt; maxHeap;&#10;        priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; minHeap;&#10;        &#10;        maxHeap.push(nums[0]);&#10;        result.push_back(nums[0]);&#10;        for (int i = 1; i &amp;lt; n; i++) {&#10;            if (nums[i] &amp;lt; maxHeap.top())&#10;                maxHeap.push(nums[i]);&#10;            else&#10;                minHeap.push(nums[i]);&#10;            &#10;            if (maxHeap.size() &amp;gt; minHeap.size() + 1) {&#10;                minHeap.push(maxHeap.top());&#10;                maxHeap.pop();&#10;            }&#10;            else if (maxHeap.size() &amp;lt; minHeap.size()) {&#10;                maxHeap.push(minHeap.top());&#10;                minHeap.pop();&#10;            }&#10;            result.push_back(maxHeap.top());&#10;        }&#10;        return result;&#10;    }&#10;};&#10;" /></outline>
      </outline>
    </outline>
  </body>
</opml>
